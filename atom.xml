<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wo-wo.github.io</id>
    <title>石强博客</title>
    <updated>2021-10-12T03:49:14.133Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wo-wo.github.io"/>
    <link rel="self" href="https://wo-wo.github.io/atom.xml"/>
    <subtitle>勤学如春起之苗，不见其增，日有所长&lt;br&gt;
辍学如磨刀之秋，不见其损，日有所亏</subtitle>
    <logo>https://wo-wo.github.io/images/avatar.png</logo>
    <icon>https://wo-wo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 石强博客</rights>
    <entry>
        <title type="html"><![CDATA[go学习-20.性能调优：分析工具]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-20xing-neng-diao-you-fen-xi-gong-ju/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-20xing-neng-diao-you-fen-xi-gong-ju/">
        </link>
        <updated>2021-10-12T03:19:35.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="pprof">pprof</h2>
<p>软件开发过程中，项目上线并不是终点。上线后，还要对程序的取样分析运行情况，并重构现有的功能，让程序执行更高效更稳写。 golang的工具包内自带pprof功能，使找出程序中占内存和CPU较多的部分功能方便了不少。加上uber的火焰图，可视化显示，让我们在分析程序时更简单明了。</p>
<h3 id="准备工作">准备工作</h3>
<ul>
<li>安装graphviz
<ul>
<li>brew install graphviz</li>
</ul>
</li>
<li>将 $GOPATH/bin 加⼊ $PATH
<ul>
<li>Mac OS: 在 .bash_profile 中修改路径</li>
</ul>
</li>
<li>安装 go-torch（不使用可以不装）
<ul>
<li>go get github.com/uber/go-torch</li>
<li>下载并复制 flamegraph.pl （https://github.com/brendangregg/FlameGraph）⾄ $GOPATH/bin 路径下</li>
<li>将 $GOPATH/bin 加⼊ $PATH</li>
</ul>
</li>
</ul>
<h3 id="pprof-2">pprof</h3>
<ul>
<li>
<p>采样方式：</p>
<ul>
<li>runtime/pprof：工具型应用，采集程序（非 Server）的运行数据进行分析</li>
<li>net/http/pprof：服务型应用，采集 HTTP Server 的运行时数据进行分析</li>
</ul>
</li>
<li>
<p>支持模式：</p>
<ul>
<li>Report generation：报告生成</li>
<li>Interactive terminal use：交互式终端使用</li>
<li>Web interface：Web 界面</li>
</ul>
</li>
<li>
<p>分析类型</p>
<ul>
<li>
<p>CPU Profiling：</p>
<blockquote>
<p>CPU 分析是最常见的性能分析类型。</p>
<p>按照一定的频率（默认10ms一次）采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。</p>
</blockquote>
</li>
<li>
<p>Memory Profiling：</p>
<blockquote>
<p>内存性能分析记录堆内存分配时的堆栈信息，忽略栈内存分配信息。</p>
<p>内存性能分析启用时，默认每1000次采样1次，这个比例是可以调整的。因为内存性能分析是基于采样的，因此基于内存分析数据来判断程序所有的内存使用情况是很困难的。</p>
</blockquote>
</li>
<li>
<p>Block Profiling：</p>
<blockquote>
<p>阻塞性能分析是 Go 特有的。</p>
<p>阻塞性能分析用来记录一个协程等待一个共享资源花费的时间。在判断程序的并发瓶颈时会很有用。阻塞的场景包括：</p>
<ul>
<li>在没有缓冲区的信道上发送或接收数据。</li>
<li>从空的信道上接收数据，或发送数据到满的信道上。</li>
<li>尝试获得一个已经被其他协程锁住的排它锁。</li>
</ul>
<p>一般情况下，当所有的 CPU 和内存瓶颈解决后，才会考虑这一类分析。</p>
<p>默认不开启，需要调用 <code>runtime.SetBlockProfileRate</code> 进行设置。</p>
</blockquote>
</li>
<li>
<p>Mutex Profiling：</p>
<blockquote>
<p>锁性能分析与阻塞分析类似，但专注于因为锁竞争导致的等待或延时。</p>
<p>默认不开启，需要调用 <code>runtime.SetMutexProfileFraction</code> 进行设置。</p>
</blockquote>
</li>
<li>
<p>Goroutine Profiling：</p>
<blockquote>
<p>Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。这项功能在实际排查中会经常用到，因为很多问题出现时的表象就是 Goroutine 暴增，而这时候我们要做的事情之一就是查看应用程序中的 Goroutine 正在做什么事情，因为什么阻塞了，然后再进行下一步。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="采样">采样</h3>
<h4 id="runtimepprof工具型应用">runtime/pprof：工具型应用</h4>
<ul>
<li>通过嵌入代码，手动调用 runtime/pprof 的 API</li>
<li>灵活性⾼，适⽤于特定代码段的分析</li>
<li>API 相关⽂档 https://studygolang.com/static/pkgdoc/pkg/runtime_pprof.htm</li>
<li>go tool pprof [binary] [binary.prof]</li>
</ul>
<h6 id="开启方式">开启方式</h6>
<pre><code>import &quot;runtime/pprof&quot;
//cpu
f, err := os.Create(&quot;cpu.prof&quot;) //创建一个文件句柄
pprof.StartCPUProfile(f) //开启
pprof.StopCPUProfile() //关闭
//内存
pprof.WriteHeapProfile(f1)
</code></pre>
<h4 id="nethttppprof服务型应用">net/http/pprof：服务型应用</h4>
<ul>
<li>简单，适合于持续性运⾏的应⽤</li>
<li>在应⽤程序中导⼊ import _ &quot;net/http/pprof&quot;，并启动 http server 即可</li>
<li>http://<host>:<port>/debug/pprof/</li>
<li>go tool pprof http://<host>:<port>/debug/pprof/profile?seconds=10 （默认值为30秒）</li>
<li>go-torch -seconds 10 http://<host>:<port>/debug/pprof/profile</li>
</ul>
<h6 id="开启方式-2">开启方式</h6>
<pre><code>//http包使用方式
//如果使用了默认的http.DefaultServeMux（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)），只需要import _ &quot;net/http/pprof&quot;即可
//如果使用的是自定义的 Mux，则需要手动注册一些路由规则：
r.HandleFunc(&quot;/debug/pprof/&quot;, pprof.Index)
r.HandleFunc(&quot;/debug/pprof/cmdline&quot;, pprof.Cmdline)
r.HandleFunc(&quot;/debug/pprof/profile&quot;, pprof.Profile)
r.HandleFunc(&quot;/debug/pprof/symbol&quot;, pprof.Symbol)
r.HandleFunc(&quot;/debug/pprof/trace&quot;, pprof.Trace)

//gin框架使用方式
//1、github.com/gin-contrib/pprof
//2、github.com/DeanThompson/ginpprof
import &quot;github.com/gin-contrib/pprof&quot;
pprof.Register(r)
</code></pre>
<h6 id="文件地址">文件地址</h6>
<pre><code># http://&lt;host&gt;:&lt;port&gt;/debug/pprof/
allocs：查看过去所有内存分配的样本，访问路径为 $HOST/debug/pprof/allocs。
block：查看导致阻塞同步的堆栈跟踪，访问路径为 $HOST/debug/pprof/block。
cmdline： 当前程序的命令行的完整调用路径。
goroutine：查看当前所有运行的 goroutines 堆栈跟踪，访问路径为 $HOST/debug/pprof/goroutine。
heap：查看活动对象的内存分配情况，访问路径为 $HOST/debug/pprof/heap。
mutex：查看导致互斥锁的竞争持有者的堆栈跟踪，访问路径为 $HOST/debug/pprof/mutex。
profile： 默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件，访问路径为 $HOST/debug/pprof/profile。
threadcreate：查看创建新 OS 线程的堆栈跟踪，访问路径为 $HOST/debug/pprof/threadcreate。

1、web界面点击链接默认带debug=1，若没有debug参数，那么将会直接下载对应的 profile 文件。
2、在部署环境中，为了网络安全，通常不会直接对外网暴露 pprof 的相关端口，因此会通过 curl、wget 等方式进行 profile 文件的间接拉取。
3、debug 的访问方式是具有时效性的，在实际场景中，我们常常需要及时将当前状态下的 profile 文件给存储下来，便于二次分析。
</code></pre>
<h2 id="交互式终端go-tool-pprof">交互式终端（go tool pprof）</h2>
<pre><code>#go tool pprof
go tool pprof + prof文件进入交互式终端，有以下几个命令
top  默认查看程序中占用cpu前10位的函数，后面可跟数字，默认以flat排列，可使用-cum以cum排列
list +函数名命令查看具体的函数分析
traces 查看调用链路
pdf  可以生成可视化的pdf文件。
svg  生成svg
web  直接生成关系调用图（方块越大表示消耗越大）：
     注意：如果没有安装graphviz，会出现Could not execute dot；may need to install graphviz

#top详解
(pprof) top
Showing nodes accounting for 71.27s, 75.62% of 94.25s total
Dropped 211 nodes (cum &lt;= 0.47s)
Showing top 10 nodes out of 97
      flat  flat%   sum%        cum   cum%
    23.32s 24.74% 24.74%     23.32s 24.74%  runtime.pthread_cond_wait
    10.09s 10.71% 35.45%     10.09s 10.71%  runtime.pthread_kill
    10.08s 10.69% 46.14%     10.08s 10.69%  runtime.kevent
     7.19s  7.63% 53.77%     19.04s 20.20%  main.GetFibonacciServe
     5.10s  5.41% 59.18%      5.10s  5.41%  runtime.procyield
     4.34s  4.60% 63.79%      8.12s  8.62%  runtime.scanobject
     4.17s  4.42% 68.21%      4.17s  4.42%  runtime.pthread_cond_signal
     2.72s  2.89% 71.10%      2.82s  2.99%  runtime.nanotime1
     2.32s  2.46% 73.56%      2.33s  2.47%  runtime.usleep
     1.94s  2.06% 75.62%      1.94s  2.06%  runtime.memclrNoHeapPointers
     
flat：当前函数占用CPU的耗时
flat%：当前函数占用CPU的耗时百分比
sum%：函数占用CPU的累积耗时百分比
cum：当前函数+调用当前函数的占用CPU总耗时
cum%：当前函数+调用当前函数的占用CPU总耗时百分比

【flat和cum的区别】假设函数b由三部分组成：调用函数c、自己直接处理一些事情、调用函数d，其中调用函数c耗时1秒，自己直接处理事情耗时3秒，调用函数d耗时2秒，那么函数b的flat耗时就是3秒，cum耗时就是6秒。
【flat%、cum%、sum%】flat%和cum%指的就是flat耗时和cum耗时占总耗时（也就是94.25秒）的百分比，而最后一个sum%指的就是每一行的flat%与上面所有行的flat%总和，代表从上到下的累计值，比如第二行的75.04%就等于第一行flat%的66.67%+本行flat%的8.37%，下面的以此类推
</code></pre>
<h4 id="cpu-profiling">CPU Profiling</h4>
<pre><code>go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30
// 执行该命令后，需等待 30 秒（可调整 seconds 的值），pprof 会进行 CPU Profiling，结束后将默认进入 pprof 的命令行交互式模式，可以对分析的结果进行查看或导出。另外如果你所启动的 HTTP Server 是 TLS 的方式，那么在调用 go tool pprof 时，需要将调用路径改为：
go tool pprof https+insecure://localhost:6060/debug/pprof/profile?seconds=30。
</code></pre>
<h4 id="heap-profiling">Heap Profiling</h4>
<pre><code>go tool pprof http://localhost:6060/debug/pprof/heap
// 执行该命令后，能够很快的拉取到其结果，因为它不需要像 CPU Profiling 做采样等待

// 可以选择传 type 它默认显示的是 inuse_space，实际上可以针对多种内存概况进行分析，常用的类别如下：
inuse_space：分析应用程序的常驻内存占用情况。
alloc_objects：分析应用程序的内存临时分配情况。
//另外还有 inuse_objects 和 alloc_space 类别，分别对应查看每个函数所分别的对象数量和查看分配的内存空间大小，具体可根据情况选用。
go tool pprof -alloc_objects http://localhost:6060/debug/pprof/heap
</code></pre>
<h4 id="goroutine-profiling">Goroutine Profiling</h4>
<pre><code>// 在查看 goroutine 时，我们可以使用 traces 命令，这个命令会打印出对应的所有调用栈，以及指标信息，可以让我们很便捷的查看到整个调用链路有什么，分别在哪里使用了多少个 goroutine，并且能够通过分析查看到谁才是真正的调用方
</code></pre>
<h4 id="mutex-profiling">Mutex Profiling</h4>
<pre><code>// 需要注意的是 runtime.SetMutexProfileFraction 语句，如果未来希望进行互斥锁的采集，那么需要通过调用该方法来设置采集频率，若不设置或没有设置大于 0 的数值，默认是不进行采集的。
func init() {
	runtime.SetMutexProfileFraction(1)
}
</code></pre>
<h4 id="block-profiling">Block Profiling</h4>
<pre><code>// 与 Mutex 的 runtime.SetMutexProfileFraction 相似，Block 也需要调用 runtime.SetBlockProfileRate() 进行采集量的设置，否则默认关闭，若设置的值小于等于 0 也会认为是关闭。
func init() {
	runtime.SetBlockProfileRate(1)
}
</code></pre>
<h2 id="web-界面">Web 界面</h2>
<p>方法一（推荐）：</p>
<pre><code># 该命令将在所指定的端口号运行一个 PProf 的分析用的站点。
go tool pprof -http=:6001 profile

# 包含内容：
# Top
# Graph
# Flame Graph （火焰图）
# Peek 相较于 Top 视图，增加了所属的上下文信息的展示，也就是函数的输出调用者/被调用者。
# Source 主要是增加了面向源代码的追踪和分析，可以看到其开销主要消耗在哪里。
# Disassemble
</code></pre>
<p>方法二：</p>
<pre><code># 在go tool pprof交互式终端中使用web命令
(pprof) web
</code></pre>
<h2 id="安全地使用nethttppprof">安全地使用net/http/pprof</h2>
<h1 id="benchmark">benchmark</h1>
<ul>
<li>benchmark和普通的单元测试一样，都位于 <code>_test.go</code> 文件中。</li>
<li>函数名以 <code>Benchmark</code> 开头，参数是 <code>b *testing.B</code>。和普通的单元测试用例很像，单元测试函数名以 <code>Test</code> 开头，参数是 <code>t *testing.T</code>。</li>
<li><code>go test</code> 命令默认不运行 benchmark 用例的，如果我们想运行 benchmark 用例，则需要加上 <code>-bench</code> 参数。例如：</li>
</ul>
<pre><code>go test -bench .
// 支持正则表达式，下面这个代表运行以Fib结尾的benchmark用例：
go test -bench='Fib$' .
// 默认使用全部cpu核数，可通过-cpu参数改变，-cpu支持传入一个列表作为参数，例如：
go test -bench='Fib$' -cpu=2,4 .
// 默认运行时间为1s，可通过-benchtime指定时间或者次数：
go test -bench='Fib$' -benchtime=5s .
go test -bench='Fib$' -benchtime=50x .
// 默认执行一轮，可通过-count指定轮数：
go test -bench='Fib$' -benchtime=5s -count=3 .
// 可通过-benchmem可查看内存分配量和分配次数：
go test -bench=. -benchmem
//常用方法：
b.StopTimer() //暂停计时
b.ResetTimer() //重置定时器
b.StartTimer() //开始计时
//下面输出的意思是：通过1s时间内运行该方法33次,每次需要30403687ns，进行内存分配40次，每次分配45188395B内存
BenchmarkGenerate-8         33  30403687 ns/op  45188395 B/op  40 allocs/op
</code></pre>
<h1 id="延伸阅读">延伸阅读</h1>
<p><a href="https://deepzz.com/post/the-command-flag-of-go-test.html">Go 测试，go test 工具的具体指令 flag</a></p>
<p><a href="https://golang2.eddycjy.com/posts/ch6/03-trace/">go tool trace</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-19.go web request]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-19go-web-request/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-19go-web-request/">
        </link>
        <updated>2021-10-12T03:18:20.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1资料">1.资料</h3>
<ul>
<li>《Go Web 编程》</li>
<li><a href="https://www.yuque.com/bobby-zpcyu/fgg66n/hi6mlb">慕课网-Go开发工程师-课程文档</a></li>
<li><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949412">Gin 中文文档</a></li>
<li><a href="https://www.yuque.com/xinliangnote/go-gin-api/ngc3x5">go-gin-api 文档</a></li>
<li><a href="http://doc.go-admin.cn/zh/">GoAdmin文档</a></li>
</ul>
<h3 id="2nethttp包">2.net/http包</h3>
<blockquote>
<p>与 http 交互，都是基于基础包 net/http；<br>
例如：gin 等</p>
</blockquote>
<p>问题：</p>
<ul>
<li>1.Go Web 编程，看下来，整体感受如何？</li>
<li>2.go web https服务器，如何搭建？</li>
<li>3.多路复用器的意义是什么？</li>
<li>4.处理器函数的原理、意义是什么？</li>
</ul>
<p>核心：</p>
<ul>
<li>DefaultServeMux 单例</li>
<li>处理器函数（HandlerFunc）</li>
<li>ListenAndServer()</li>
</ul>
<h4 id="1构建-go-web-服务器">1.构建 go web 服务器</h4>
<h5 id="1最简单的服务器">1.最简单的服务器</h5>
<pre><code>import (
	&quot;net/http&quot;
)

func main()  {
	//启动一个http服务器，监听8080端口。默认端口可省
	//nil：使用默认多路复用器 DefaultServeMux
	//问题：参数是处理器，为什么默认使用多路复用器？
	http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>
<h5 id="2附加配置的服务器">2.附加配置的服务器</h5>
<p>1.Server结构体</p>
<pre><code>type Server struct {
	Addr           string
	Handler        Handler
	ReadTimeout    time.Duration
	WriteTimeout   time.Duration
	MaxHeaderBytes int
	# https
	TLSConfig      *tls.Config
	TLSNextProto   map[string]func(*Server, *tls.Conn, Handler)
	
	ConnState      func(net.Conn, ConnState)
	ErrorLog       *log.Logger
	...
}
</code></pre>
<p>2.增加一些配置</p>
<pre><code>func main()  {
	server := http.Server{
		Addr: &quot;127.0.0.1:8080&quot;,
		Handler: nil,
	}
	server.ListenAndServe()
}
</code></pre>
<h5 id="3https-的服务器">3.HTTPS 的服务器</h5>
<pre><code>func main()  {
	server := http.Server{
		Addr: &quot;127.0.0.1:8080&quot;,
		Handler: nil,
	}
	server.ListenAndServeTLS(&quot;cert.pem&quot;, &quot;key.pem&quot;)
}
</code></pre>
<h4 id="2处理请求">2.处理请求</h4>
<h5 id="1处理器-handler">1.处理器 Handler</h5>
<blockquote>
<p>一个处理器就是一个拥有 ServeHTTP 方法，且签名相同（即参数相同）的接口</p>
</blockquote>
<pre><code># 注意是 ServeHTTP，不是 ServerHTTP
ServeHTTP(http.ResponseWriter, *http.Request)
</code></pre>
<h5 id="2多路复用器-defaultservemux">2.多路复用器 DefaultServeMux</h5>
<ul>
<li>
<p>不仅是多路复用器，还是一个处理器</p>
<blockquote>
<p>DefaultServeMux 是 ServeMux结构 的一个实例，而后者拥有 ServerHTTP 方法；<br>
即：DefaultServeMux 即是 ServeMux结构 的实例，也是 Handler 结构 的实例；</p>
</blockquote>
</li>
<li>
<p>多路复用器作用</p>
</li>
</ul>
<blockquote>
<p>是一个特殊处理器，唯一作用：根据请求的 URL 将请求重定向到不同处理器</p>
</blockquote>
<h5 id="3自定义处理器">3.自定义处理器</h5>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type MyHandler struct {}

func (h *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello world!&quot;)
}

func main()  {
	handler:= MyHandler{}
	server := http.Server{
		Addr: &quot;127.0.0.1:8080&quot;,
		Handler: &amp;handler,
	}
	//http://localhost:10000/
	//http://localhost:10000/aa/bb
	server.ListenAndServe()
}
</code></pre>
<p>浏览器访问 http://localhost:8080/，就可看到 Hello world 响应</p>
<p>4.问题：如果此时浏览器输入 http://localhost:8080/anything/all，结果是什么？</p>
<p>原因：使用自定义处理器，代替了默认 多路复用器；<br>
多路复用器作用：根据请求的 URL 将请求重定向到不同处理器；<br>
所以：直接使用自定义处理器处理所有请求，不论访问什么都是 Hello world 响应</p>
<h5 id="4使用多个处理器">4.使用多个处理器</h5>
<blockquote>
<p>1.服务器使用默认的 DefaultServeMux 作为处理器；不在 Server 结构的 Handler 字段中指定处理器<br>
2.通过 http.Handle 函数将处理器绑定到 DefaultServeMux</p>
</blockquote>
<p>注：Handle 函数虽然来源于 http 包，实际上是 ServeMux 结构的方法；http.Handle 等同 DefaultServeMux.Handle</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type HelloHandler struct {}

func (h *HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello!&quot;)
}

type WorldHandler struct {}

func (h *WorldHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;world!&quot;)
}

func main()  {
	hello:= HelloHandler{}
	world:= WorldHandler{}
	server := http.Server{
		Addr: &quot;127.0.0.1:10000&quot;,
	}
	http.Handle(&quot;/hello&quot;, &amp;hello)
	http.Handle(&quot;/world&quot;, &amp;world)
	
	//http://localhost:10000/
	//http://localhost:10000/hello
	//http://localhost:10000/world
	server.ListenAndServe()
}
</code></pre>
<h5 id="5处理器函数">5.处理器函数</h5>
<blockquote>
<p>处理器函数就是创建处理器的一种便利方式</p>
</blockquote>
<p>1.处理器函数</p>
<blockquote>
<p>1.与处理器拥有相同行为的函数；<br>
2.这些函数与 ServeHTTP 方法拥有相同的签名（即参数相同）；</p>
</blockquote>
<p>2.处理器函数实现原理</p>
<blockquote>
<p>定义了一种 HandlerFunc 函数类型，可以将一个带有正确签名的函数 f 转换成一个带有方法 f 的处理器</p>
</blockquote>
<p>1.例：</p>
<pre><code>func hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello!&quot;)
}

//HandlerFunc，将 hello 函数，转换成一个带有 hello 方法的处理器 helloHandler
//HandlerFunc 是定义的一种类型，此处是类型强制转化
helloHandler := HandlerFunc(hello)
</code></pre>
<p>2.源码：HandlerFunc定义</p>
<pre><code>type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
</code></pre>
<p>3.例：http.HandleFunc()</p>
<blockquote>
<p>注：不是 http.HandlerFunc()，二者意义不一样</p>
</blockquote>
<ul>
<li>HandleFunc()：封装的简化处理器定义的方法，底层调用 HandlerFunc()，进行类型转化</li>
<li>HandlerFunc()：定义的一种函数类型，将带有正确签名的函数 f 转换成一个带有方法 f 的处理器</li>
</ul>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

//与上边多处理器函数，函数定位对比
func hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello!&quot;)
}

func world(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;world!&quot;)
}

func main()  {
	server := http.Server{
		Addr: &quot;127.0.0.1:10000&quot;,
	}
	http.HandleFunc(&quot;/hello&quot;, hello)
	http.HandleFunc(&quot;/world&quot;, world)
	
	//http://localhost:10000/
	//http://localhost:10000/hello
	//http://localhost:10000/world
	server.ListenAndServe()
}
</code></pre>
<h5 id="6串联多个处理和和处理器函数">6.串联多个处理和和处理器函数</h5>
<blockquote>
<p>意义：防止代码重复、代码依赖</p>
</blockquote>
<p>串联处理器函数</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

func helloWorld(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello world!\n&quot;)
}

//串联时注意函数类型
func log(h http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &quot;log!\n&quot;)
		h(w, r)
	}
}

func main()  {
	server := http.Server{
		Addr: &quot;127.0.0.1:10000&quot;,
	}
	http.HandleFunc(&quot;/hello&quot;, log(helloWorld))
	//http://localhost:10000/hello
	server.ListenAndServe()
}
</code></pre>
<h5 id="6servemux-和-defaultservemux">6.ServeMux 和 DefaultServeMux</h5>
<p>1.ServeMux</p>
<blockquote>
<p>1.是一个 HTTP请求的多路复用器；<br>
2.ServeMux 结构包含一个映射：URL映射到对应处理器（找出最为匹配的 URL）；<br>
3.因为ServeMux 结构实现了 ServeHTTP，所以是个处理器；</p>
</blockquote>
<p>2.DefaultServeMux</p>
<blockquote>
<p>1.是 ServeMux 结构的一个实例（不是实现）</p>
</blockquote>
<p>3.URL匹配规则</p>
<blockquote>
<p>1.如果绑定的 URL 不是以 / 结尾，完全匹配；<br>
2.如果绑定的 URL 是以 / 结尾（/hello/），往前匹配（/hello/aa）；</p>
</blockquote>
<h5 id="7其它多路复用器-httrouter">7.其它多路复用器 HttRouter</h5>
<blockquote>
<p>ServeMux缺陷：无法使用变量实现 URL 模式匹配</p>
</blockquote>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/julienschmidt/httprouter&quot;
	&quot;net/http&quot;
)

func hello2(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
	fmt.Fprintf(w, &quot;Hello %s!&quot;, p.ByName(&quot;name&quot;))
}


func main()  {
	mux := httprouter.New()
	mux.GET(&quot;/hello/:name&quot;, hello2)

	server := http.Server{
		Addr: &quot;127.0.0.1:10000&quot;,
	}
	server.ListenAndServe()
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-18.框架-gin]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-18kuang-jia-gin/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-18kuang-jia-gin/">
        </link>
        <updated>2021-10-12T03:17:51.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1安装">1.安装</h3>
<pre><code># 1.下载并安装
go get -u github.com/gin-gonic/gin

# 2.创建项目
mkdir ~/go_mod/ginTest
cd ~/go_mod/ginTest
go mod init ginTest

</code></pre>
<h4 id="1错误">1.错误</h4>
<p>1.go get ... time out</p>
<blockquote>
<p>注释掉 /etc/hosts 中的 github<br>
防止有其它代理，重启电脑</p>
</blockquote>
<h3 id="2快速开始">2.快速开始</h3>
<p>1.定义路由、监听端口</p>
<pre><code>package main

import (
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

func main() {
	// 使用默认中间件创建一个gin路由器
	// logger and recovery (crash-free) 中间件
	r := gin.Default()
	//定义get请求，路由user
	r.GET(&quot;/user&quot;, func(c *gin.Context) {
		//响应。字符串
		c.String(http.StatusOK, &quot;test&quot;)
	})

	// 默认启动的是 8080端口，也可以自己定义启动端口
	// router.Run(&quot;:3000&quot;)
	r.Run()
}
</code></pre>
<p>2.启动服务</p>
<pre><code># 会自动监听端口，不需要nginx等web配置
go run main.go
</code></pre>
<p>3.测试</p>
<pre><code># 端口不可省略
curl http://localhost:8080/user
</code></pre>
<h3 id="3常用功能">3.常用功能</h3>
<h4 id="1请求参数">1.请求参数</h4>
<h5 id="1get请求">1.GET请求</h5>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

func main() {
	r := gin.Default()
	//声明1：路由中声明参数
	r.GET(&quot;/user/:name/:action/&quot;, func(c *gin.Context) {
        name := c.Param(&quot;name&quot;)
        action := c.Param(&quot;action&quot;)
        c.String(http.StatusOK, &quot;%s is %s&quot;, name, action)
    })
    //声明2：*后的所有路由都作为参数action的值
    r.GET(&quot;/user/:name/*action&quot;, func(c *gin.Context) {
        name := c.Param(&quot;name&quot;)
        action := c.Param(&quot;action&quot;)
        c.String(http.StatusOK, &quot;%s is %s&quot;, name, action)
    })
	//声明3：从&amp;中获取参数
	r.GET(&quot;/user/login&quot;, func(c *gin.Context) {
		//接收get请求参数
		name := c.DefaultQuery(&quot;name&quot;, &quot;tom&quot;)
		password := c.Query(&quot;password&quot;)//c.Request.URL.Query().Get(&quot;&quot;)的简写
		//获取数组（字符串切片）
		common := c.QueryArray(&quot;common&quot;)

		fmt.Printf(&quot;name is %s, password is %s \n&quot;, name, password)
		fmt.Println(&quot;common params is: \n&quot;, common)

		c.String(http.StatusOK, &quot;Hi %s, welcome!&quot;, name)
	})
	r.Run()
}
</code></pre>
<p>验证</p>
<pre><code># 监听端口
go run main.go

# 测试
curl http://localhost:8080/user/login\?name\=john\&amp;password\=123456\&amp;common=1,2
</code></pre>
<h5 id="2post请求">2.POST请求</h5>
<blockquote>
<p>post请求，允许传递get形式的参数，通过get方式获取到对应参数</p>
</blockquote>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

func main() {
	r := gin.Default()

	r.POST(&quot;/user/welcome&quot;, func(c *gin.Context) {
		name := c.PostForm(&quot;name&quot;)
		common := c.PostFormArray(&quot;common&quot;)

		fmt.Printf(&quot;name is %s\n&quot;, name)
		fmt.Println(&quot;common is: \n&quot;, common)

		c.JSON(http.StatusOK, gin.H{
			&quot;status&quot;: http.StatusOK,
			&quot;message&quot;: &quot;success&quot;,
		})
	})
	r.Run()
}
</code></pre>
<p>验证</p>
<pre><code># 监听端口
go run main.go

# 测试
curl -X POST -d &quot;name=quene&amp;common=1,2&quot;  http://localhost:8080/user/welcome
</code></pre>
<h4 id="2路由">2.路由</h4>
<h5 id="1路由分组">1.路由分组</h5>
<pre><code>func main() {
	router := gin.Default()

	// Simple group: v1
	v1 := router.Group(&quot;/v1&quot;)
	{
		v1.POST(&quot;/login&quot;, loginEndpoint)
		v1.POST(&quot;/submit&quot;, submitEndpoint)
		v1.POST(&quot;/read&quot;, readEndpoint)
	}

	// Simple group: v2
	v2 := router.Group(&quot;/v2&quot;)
	{
		v2.POST(&quot;/login&quot;, loginEndpoint)
		v2.POST(&quot;/submit&quot;, submitEndpoint)
		v2.POST(&quot;/read&quot;, readEndpoint)
	}

	router.Run(&quot;:8080&quot;)
}
</code></pre>
<h4 id="3中间件">3.中间件</h4>
<pre><code># 1.无中间件启动
r := gin.New()

# 2.添加中间件
# gin中 HandlerFunc 都是中间件
r.Use(gin.Logger())

# 3.路由添加中间件，可以添加任意多个
r.GET(&quot;/user/login&quot;, AuthRequired(), loginEndpoint)
</code></pre>
<h4 id="4日志">4.日志</h4>
<pre><code>
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-17.命令行程序库-cobra]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-17ming-ling-xing-cheng-xu-ku-cobra/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-17ming-ling-xing-cheng-xu-ku-cobra/">
        </link>
        <updated>2021-10-12T03:17:19.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<p><a href="https://zhuanlan.zhihu.com/p/103363533">Go 每日一库之 cobra</a></p>
<blockquote>
<p>编写命令行程序；<br>
同时，它也提供了一个脚手架（生成器），用于生成基于 cobra 的应用程序框架</p>
</blockquote>
<h3 id="1特性">1.特性</h3>
<ul>
<li>
<p>轻松支持子命令，如app server，app fetch等；</p>
</li>
<li>
<p>完全兼容 POSIX 选项（包括短、长选项）；</p>
</li>
<li>
<p>嵌套子命令；</p>
</li>
<li>
<p>全局、本地层级选项。可以在多处设置选项，按照一定的顺序取用；</p>
</li>
<li>
<p>使用脚手架轻松生成程序框架和命令；</p>
</li>
<li>
<p>设置钩子函数，在命令执行前、后执行某些操作；</p>
</li>
<li>
<p>生成 Markdown/ReStructed Text/Man Page 格式的文档；</p>
</li>
</ul>
<h3 id="2基本概念">2.基本概念</h3>
<ul>
<li>
<p>命令（Command）：就是需要执行的操作；</p>
</li>
<li>
<p>参数（Arg）：命令的参数，即要操作的对象；</p>
</li>
<li>
<p>选项（Flag）：命令选项可以调整命令的行为。</p>
</li>
</ul>
<pre><code># 例：
# hugo 命令，server 子命令，--port 选项
hugo server --port 1234
# git 命令，clone 子命令，URL 参数，--bare 选项
git clone URL --bare
</code></pre>
<h3 id="3快速使用">3.快速使用</h3>
<h4 id="1安装库">1.安装库</h4>
<blockquote>
<p>注：会在 <code>$GOPATH/bin</code> 目录下创建一个名叫cobra可执行文件。</p>
</blockquote>
<pre><code># 1.安装包 cobra
# -u：更新已有的代码包及其依赖包
# 没 -u，包已存在时，不会更新
go get -u github.com/spf13/cobra/cobra

# 2.确认 cobra 是否被安装在了 $GOPATH/bin下
# 注：防止 $GOPATH 失效，导致安装的 go 命令，不可执行
ls -al $GOPATH/bin | grep cobra
</code></pre>
<h4 id="2错误command-not-found-cobra">2.错误：command not found: cobra</h4>
<blockquote>
<p>cobra没能正常安装。<br>
引入 $GOPATH，重新安装</p>
</blockquote>
<ul>
<li>注1：电脑重启后，~/.base_profile 定义的 $GOPATH 可能会失效</li>
<li>注2：已经安装过的go命令，后续突然不可执行了，基本都是 $GOPATH 失效，例：gmchart</li>
</ul>
<p><img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210323160756.png" alt="" loading="lazy"><br>
<img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210323160820.png" alt="" loading="lazy"></p>
<h4 id="3脚手架">3.脚手架</h4>
<pre><code># 1.初始化
# appName：项目名，只能是相对路径
# --pkg-name：包名。main.go 中 import 的包名
# cobra init appName --pkg-name pgkName
cobra init go_mod/monitor --pkg-name monitor

# 2.添加子命令
cobra add {childCmd}
</code></pre>
<h5 id="1gopath">1.GOPATH</h5>
<pre><code># 1.进入 $GOPATH/src
cd $GOPATH/src

# 2.初始化
cobra init monitor --pkg-name monitor

# 3.编译
# -o：自定义编译文件名
# {cmd}：自定义可执行文件名
# 编译后的文件，可以在任意目录执行
# go build -o {cmd}
go build -o monitor

# 4.执行
./monitor
</code></pre>
<h5 id="2go-mod">2.go mod</h5>
<blockquote>
<p>非 $GOPATH 目录，需要使用 go mod 模式。<br>
否则 cobra 初始化后，找不到对应包</p>
</blockquote>
<pre><code># 1.使用 cobra 生成项目
cobra init monitorCobra --pkg-name monitorCobra

# 2.使用 go mod
cd monitorCobra
go mod init monitorCobra

# 3.下载依赖包 go mod
# go1.15
go mod download
go run main.go
# go1.16
go mod vendor
# 第三种
go mod tidy -v

# 4.重新在 ide 打开

# 5.编译
go build -o monitor

# 6.执行
./monitor
</code></pre>
<h3 id="4简单介绍">4.简单介绍</h3>
<h4 id="1执行">1.执行</h4>
<pre><code># 1.执行
# 不要直接 go run，需要编译成可执行命令
go build -o {cmd}

# 2.帮助信息
./{cmd} -h
./{cmd} {child_cmd} -h
</code></pre>
<h4 id="2命令">2.命令</h4>
<blockquote>
<p>命令、子命令，都是用 Cobra.Command{}结构体表示；<br>
常用的结构体属性：Use/Short/Long/Run</p>
</blockquote>
<pre><code># 1.Use：命令怎么被调用
# 格式：name arg1 [arg2]
# name命令，arg1必填参数，arg2可选参数，参数可以多个

# 2.Short/Long：命令的帮助信息，前者简短，后者详尽

# 3.Run：实际执行操作的函数
</code></pre>
<h4 id="3选项">3.选项</h4>
<blockquote>
<p>永久选项（命令、子命令都可使用）<br>
本地选项（子命令）<br>
pflag包解析</p>
</blockquote>
<pre><code># 1.永久选项 rootCmd
# 参数：接收变量、长选项、短选项名、默认值和、帮助信息
var Verbose bool
rootCmd.PersistentFlags().BoolVarP(&amp;Verbose, &quot;verbose&quot;, &quot;v&quot;, false, &quot;verbose output&quot;)

# 2.本地选项 {childCmd}
var Source string
{childCmd}.Flags().StringVarP(&amp;Source, &quot;source&quot;, &quot;s&quot;, &quot;&quot;, &quot;Source directory to read from&quot;)
</code></pre>
<h4 id="4配置文件">4.配置文件</h4>
<pre><code># 方法1.脚手架生成后，会自动绑定选项 config，允许在命令行中指定
func init() {
    // initConfig 函数会在绑定选项后，才执行
	cobra.OnInitialize(initConfig)

    rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (default is $HOME/.monitorCobra.yaml)&quot;)
}

func initConfig() {...}

# 方法2.手动在项目中写死
func initConfig() {
    //直接写死，不接收选项自定义
    cfgFile = &quot;./conf/config.yaml&quot;
    ...
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-16.例：监控脚本]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-16li-jian-kong-jiao-ben/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-16li-jian-kong-jiao-ben/">
        </link>
        <updated>2021-10-12T03:16:30.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1go-mod模式">1.go mod模式</h3>
<pre><code># 1.初始化模块
go mod init [module]

# 2.下载第三方包
go mod download

# 3.ide引入第三方包（运行时会引入第三方包）
go run ...
</code></pre>
<h3 id="2go-mod-flags包">2.go mod + flags包</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210323141301.png" alt="" loading="lazy"></figure>
<p>1.新建包</p>
<pre><code>mkdir monitor
go mod init monitor
</code></pre>
<p>2.新增 main.go</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;monitor/helpers&quot;
	&quot;path&quot;
	&quot;runtime&quot;
	&quot;strings&quot;
)

var (
	processName string
	cmd string
	currFileName string
)

func init()  {
	flag.StringVar(&amp;processName, &quot;processName&quot;, &quot;&quot;, &quot;var process name&quot;)

	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yml&quot;)
	viper.AddConfigPath(&quot;./conf&quot;)
	err := viper.ReadInConfig()
	if err != nil {
		fmt.Printf(&quot;配置文件读取失败：%s&quot;, err.Error())
	}
}

func main() {
	getCurrFileName()
	getCmd()
	helpers.Monitor(cmd, processName)

	//读取db配置
	//db := structs.Db{}
	//db.ShowConfInfo()
}

func getCmd()  {
	flag.Parse()

	//获取进程id，排除grep进程、当前go进程
	//问题：字符串拼接有几种方式？
	cmd = &quot;ps -ef | grep &quot; + processName + &quot; | grep -v grep | grep -v &quot; + currFileName + &quot; | awk '{print $2}'&quot;
	fmt.Printf(&quot;cmd：%s \n&quot;, cmd)
}

func getCurrFileName()  {
	//fmt.Println(os.Args)
	//文件全路径
	_, fullFileName, _, _ := runtime.Caller(0)

	//文件名
	fileName := path.Base(fullFileName)
	//后缀名
	fileSuffix := path.Ext(fileName)
	//不含后缀的文件名
	currFileName = strings.TrimSuffix(fileName, fileSuffix)
	fmt.Printf(&quot;当前文件名称：%s \n&quot;, currFileName)
}
</code></pre>
<p>3.新增配置文件 conf.yml</p>
<pre><code>dingDing:
  url: &quot;https://oapi.dingtalk.com/robot/send?access_token=ae4f397ec3fc9310ce418dd23ac4649631b75bc1128836fdb8f8bef89fb27d3c&quot;
db:
  redis:
    ip: &quot;127.0.0.1&quot;
    port: &quot;6379&quot;
    aa: &quot;11&quot;
  mysql:
    ip: &quot;127.0.0.1&quot;
    port: &quot;3306&quot;
    bb: &quot;22&quot;
</code></pre>
<p>4.新增结构体</p>
<pre><code># 1.db 结构体
package structs

import (
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
)

type Db struct {
	Db DbConf
}

type DbConf struct {
	Redis Redis
	Mysql Mysql
}

type Redis struct {
	Ip string
	Port string
	Aa string
}

type Mysql struct {
	Ip string
	Port string
	Bb string
}

func (d *Db) ShowConfInfo()  {
	viper.Unmarshal(d)

	fmt.Printf(&quot;mysql ip：%s，port: %s \n&quot;, d.Db.Mysql.Ip, d.Db.Mysql.Port)
	fmt.Printf(&quot;redis ip：%s，port: %s \n&quot;, d.Db.Redis.Ip, d.Db.Redis.Port)
}

# 2.dingding结构体
package structs

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
	&quot;strings&quot;
)

type DingDing struct {
	DingDing DingConf
}

type DingConf struct {
	Url string
}

func (d *DingDing) SendDingMsg(url, title, msg string) bool {
	format := `### %s \n\n #### %s \n\n`
	text := fmt.Sprintf(format, title, msg)
	content := `{&quot;msgtype&quot;: &quot;markdown&quot;,
					&quot;markdown&quot;: {
            			&quot;title&quot;:&quot;` + title + `&quot;,
            			&quot;text&quot;: &quot;` + text + `&quot;
        			}
			}`
	req, err := http.NewRequest(&quot;POST&quot;, url, strings.NewReader(content))
	if err != nil {
		fmt.Printf(&quot;建立请求失败：%s&quot;, err.Error())
		return false
	}
	req.Header.Set(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;)

	client := &amp;http.Client{}
	rst, err := client.Do(req)
	defer rst.Body.Close()
	if err != nil {
		fmt.Printf(&quot;请求发送失败：%s&quot;, err.Error())
		return false
	}

	return true
}
</code></pre>
<p>5.新增 helpers</p>
<pre><code># 1.monitor类
package helpers

import (
	&quot;fmt&quot;
	&quot;os/exec&quot;
	&quot;strings&quot;
)

func Monitor(cmd, processName string) {
	rst, err := exec.Command(&quot;/bin/sh&quot;, &quot;-c&quot;, cmd).Output()
	if err != nil {
		fmt.Printf(&quot;cmd exec failed! %s \n&quot;, err.Error())
	}

	//将字节转化成字符串，去掉2边的空格
	pid := strings.TrimSpace(string(rst))
	if pid == &quot;&quot; {
		//发送钉钉报警消息
		SendDingMsg(processName)
	} else {
		fmt.Printf(&quot;pid：%s \n&quot;, pid)
	}
}

# 2.common类
package helpers

import (
	&quot;github.com/spf13/viper&quot;
	&quot;monitor/structs&quot;
)

func SendDingMsg(msg string) {
	var d structs.DingDing
	viper.Unmarshal(&amp;d)

	//fmt.Println(d.DingDing.Url)
	d.SendDingMsg(d.DingDing.Url, &quot;监控脚本报警&quot;, &quot;脚本 &quot; + msg + &quot; 意外停止，请及时处理!!&quot;)
}
</code></pre>
<p>6.执行</p>
<pre><code>go run main.go -processName mysql
</code></pre>
<h3 id="3go-mod-go-flags包">3.go mod + go-flags包</h3>
<blockquote>
<p>与上诉唯一不同，声明命令行参数的方式</p>
</blockquote>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/jessevdk/go-flags&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;monitorFlags/helpers&quot;
	&quot;path&quot;
	&quot;runtime&quot;
	&quot;strings&quot;
)

var (
	processName string
	cmd string
	currFileName string
)

type Option struct {
	PName string `short:&quot;n&quot; long:&quot;pName&quot; description:&quot;var process name&quot;`
}

func init()  {
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yml&quot;)
	viper.AddConfigPath(&quot;./conf&quot;)
	err := viper.ReadInConfig()
	if err != nil {
		fmt.Printf(&quot;配置文件读取失败：%s&quot;, err.Error())
	}
}

func main() {
	getCurrFileName()
	getCmd()
	helpers.Monitor(cmd, processName)
}

func getCmd()  {
	var opt Option
	flags.Parse(&amp;opt)
	processName = opt.PName

	//获取进程id，排除grep进程、当前go进程
	//问题：字符串拼接有几种方式？
	cmd = &quot;ps -ef | grep &quot; + processName + &quot; | grep -v grep | grep -v &quot; + currFileName + &quot; | awk '{print $2}'&quot;
	fmt.Printf(&quot;cmd：%s \n&quot;, cmd)
}

func getCurrFileName()  {
	//fmt.Println(os.Args)
	//文件全路径
	_, fullFileName, _, _ := runtime.Caller(0)

	//文件名
	fileName := path.Base(fullFileName)
	//后缀名
	fileSuffix := path.Ext(fileName)
	//不含后缀的文件名
	currFileName = strings.TrimSuffix(fileName, fileSuffix)
	fmt.Printf(&quot;当前文件名称：%s \n&quot;, currFileName)
}
</code></pre>
<p>执行</p>
<pre><code>go run main.go -n mysql
</code></pre>
<h3 id="4go-mod-cobra">4.go mod + cobra</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-15.配置管理工具-viper]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-15pei-zhi-guan-li-gong-ju-viper/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-15pei-zhi-guan-li-gong-ju-viper/">
        </link>
        <updated>2021-10-12T03:16:06.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h4 id="1特性">1.特性</h4>
<ul>
<li>1.支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；</li>
<li>2.从环境变量、命令行选项和io.Reader中读取配置</li>
<li>3.可以设置监听配置文件的修改，修改时自动加载新的配置</li>
<li>4.从远程配置系统中读取和监听修改，如 etcd/Consul</li>
</ul>
<h4 id="2快速使用">2.快速使用</h4>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
)

func main()  {
	//设置文件名（不要带后缀）、类型、搜索路径（可以多个）、默认值
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	viper.AddConfigPath(&quot;.&quot;)
	viper.SetDefault(&quot;redis.port&quot;, 6379)
	err := viper.ReadInConfig()
	if err != nil {
		log.Fatal(&quot;read config failed:%v&quot;, err)
	}

	fmt.Println(viper.Get(&quot;app_name&quot;))
	fmt.Println(viper.Get(&quot;redis.port&quot;))
}
</code></pre>
<h4 id="3读取键">3.读取键</h4>
<pre><code># 1.Get(key)
# Get方法返回一个interface{}的值，使用有所不便
viper.Get(&quot;redis.port&quot;)

# 2.GetType(key)
# Type:Int/IntSlice/String/StringSlice/Time/Duration等
# 如果指定的键不存在或类型不正确，GetType方法返回对应类型的零值
viper.GetInt(&quot;redis.port&quot;)
</code></pre>
<h4 id="4设置键值">4.设置键值</h4>
<ol>
<li>可以多个地方设置，优先级（从高到低）</li>
</ol>
<ul>
<li>viper.Set()</li>
<li>命令行选项</li>
<li>环境变量</li>
<li>配置文件</li>
<li>默认值</li>
</ul>
<pre><code># 1.set
viper.Set(&quot;redis.port&quot;, 5381)

# 2.命令行选项
# viper 使用 pflag 库来解析选项
# 解析：pflag.Parse
func init() {
  pflag.Int(&quot;redis.port&quot;, 8381, &quot;Redis port to connect&quot;)

  // 绑定命令行
  viper.BindPFlags(pflag.CommandLine)
}

# 3.环境变量
func init() {
  // 绑定环境变量-全绑定
  viper.AutomaticEnv()
  
  // 绑定环境变量-单独绑定
  // 一个参数：即是键名，也是环境变量名
  viper.BindEnv(&quot;redis.port&quot;)
  // 二个参数：前边键名，后边环境变量名
  // 注：如果对应环境变量不存在，自动将键名全部转为大写再查找一次
  viper.BindEnv(&quot;go.path&quot;, &quot;GOPATH&quot;)
}
# 验证
func main() {
  // 可以设置前缀 viper.SetEnvPrefix
  // Get的时候，viper 会自动加上这个前缀再从环境变量中查找
  fmt.Println(&quot;GOPATH: &quot;, viper.Get(&quot;GOPATH&quot;))
}

# 4.配置文件
viper.SetConfigName(&quot;config&quot;)
viper.SetConfigType(&quot;yaml&quot;)
viper.AddConfigPath(&quot;.&quot;)
viper.ReadInConfig()

# 5.默认值
viper.SetDefault(&quot;redis.port&quot;, 6379)
</code></pre>
<h4 id="5读取配置">5.读取配置</h4>
<h5 id="1从ioreader中读取">1.从io.Reader中读取</h5>
<blockquote>
<p>这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。</p>
</blockquote>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
)

func main()  {
	viper.SetConfigType(&quot;toml&quot;)
	tomlConfig := []byte(`
app_name = &quot;awesome web&quot;

[redis]
ip = &quot;127.0.0.1&quot;
port = 7381
`)
	err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))
	if err != nil {
		log.Fatal(&quot;read config failed:%v&quot;, err)
	}

	fmt.Println(&quot;redis port&quot;, viper.GetInt(&quot;redis.port&quot;))
}
</code></pre>
<h5 id="2unmarshal-反序列化">2.Unmarshal 反序列化</h5>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
)

type Conf struct {
	AppName string
	Redis RedisConf
}

type RedisConf struct {
	IP string
	Port int
}

func main()  {
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	viper.AddConfigPath(&quot;.&quot;)
	err := viper.ReadInConfig()
	if err != nil {
		log.Fatal(&quot;read config failed:%v&quot;, err)
	}

	//将配置信息，反序列化到声明的结构体 Conf
	// Unmarshal：一次性将所有配置属性，发序列化到一个结构体。结构体数量，根据配置文件层级，依次定义
	// UnmarshalKey：俺需要读取指定配置内容，到某个结构体。更简洁
	var c Conf
	viper.Unmarshal(&amp;c)
	//或
	viper.UnmarshalKey(&quot;redis&quot;, &amp;c)

	fmt.Println(c.Redis)
}
</code></pre>
<h4 id="6保存配置">6.保存配置</h4>
<ul>
<li>WriteConfig:配置写到预定义路径，文件存在，覆盖。不存在，报错</li>
<li>SafeWriteConfig:配置写到预定义路径，文件存在，不覆盖</li>
<li>WriteConfigAs:保存配置到指定路径，文件存在，覆盖</li>
<li>SafeWriteConfigAs:保存配置到指定路径，文件存在，不覆盖</li>
</ul>
<pre><code>package main

import (
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
)

func main()  {
	viper.Set(&quot;redis.ip&quot;, &quot;127.0.0.1&quot;)
	viper.Set(&quot;redis.port&quot;, &quot;6379&quot;)

	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	viper.AddConfigPath(&quot;.&quot;)

	err := viper.SafeWriteConfig()
	if err != nil {
		log.Fatal(&quot;write config failed:&quot;, err)
	}
}
</code></pre>
<h4 id="7监听文件修改">7.监听文件修改</h4>
<blockquote>
<p>可以监听文件修改，热加载配置，不需要重启<br>
viper.WatchConfig()</p>
</blockquote>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
	&quot;time&quot;
)

func main() {
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	viper.AddConfigPath(&quot;.&quot;)
	err := viper.ReadInConfig()
	if err != nil {
		log.Fatal(&quot;read config failed:&quot;, err)
	}

	//监听文件修改，热加载配置
	viper.WatchConfig()
	fmt.Println(&quot;redis port before sleep:&quot;, viper.Get(&quot;redis.port&quot;))
	time.Sleep(time.Second * 10)
	fmt.Println(&quot;redis port after sleep:&quot;, viper.Get(&quot;redis.port&quot;))
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-14.解析命令行选项-拓展-go-flags]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-14jie-xi-ming-ling-xing-xuan-xiang-tuo-zhan-go-flags/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-14jie-xi-ming-ling-xing-xuan-xiang-tuo-zhan-go-flags/">
        </link>
        <updated>2021-10-12T03:15:32.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<p><a href="https://zhuanlan.zhihu.com/p/102579462">Go 每日一库之 go-flags</a></p>
<blockquote>
<p>（第三方库，非常强大）<br>
利用结构标签（struct tag）和反射提供了一个方便、简洁的接口</p>
</blockquote>
<h4 id="1与flag比较">1.与flag比较</h4>
<p>#####1.flag缺点</p>
<ul>
<li>
<p>1.不显示支持短选项</p>
<blockquote>
<p>可以将两个选项共享同一个变量迂回实现</p>
</blockquote>
</li>
<li>
<p>2.选项变量的定义比较繁琐</p>
<blockquote>
<p>每个选项都需要根据类型调用对应的Type或TypeVar函数</p>
</blockquote>
</li>
<li>
<p>3.默认只支持有限的数据类型</p>
<blockquote>
<p>基本类型bool/int/uint/string和time.Duration</p>
</blockquote>
</li>
</ul>
<p>#####2.go-flags 丰富特性</p>
<ul>
<li>1.支持短选项（-v）和长选项（--verbose）</li>
<li>2.支持短选项合写，如-aux</li>
<li>3.同一个选项可以设置多个值</li>
<li>4.支持所有的基础类型和 map 类型，甚至是函数</li>
<li>5.支持命名空间和选项组</li>
<li>等等</li>
</ul>
<h4 id="2快速开始">2.快速开始</h4>
<p>1.安装库</p>
<pre><code>go get github.com/jessevdk/go-flags
</code></pre>
<p>2.编写测试文件</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/jessevdk/go-flags&quot;
)

type Option struct {
	//设置短、长选项名字、帮助信息。传参时短选项前加-，长选项前加--
	//定义布尔值切片，所以选项可以多个
	Verbose []bool `short:&quot;v&quot; long:&quot;verbose&quot; description:&quot;Show verbose message&quot;`
}

func main()  {
	var opt Option
	flags.parse(&amp;opt)

	fmt.Println(opt.Verbose)
}
</code></pre>
<p>执行</p>
<pre><code># 短、长选项
go run go_flags.go -v
go run go_flags.go --verbose
# 选项是切片，可以多个
go run go_flags.go -v --verbose
go run go_flags.go -vv
</code></pre>
<h4 id="3基本特性">3.基本特性</h4>
<h5 id="1支持丰富的数据类型">1.支持丰富的数据类型</h5>
<ul>
<li>
<p>1.所有基本类型及其切片</p>
<blockquote>
<p>切片解析与基本类型一致<br>
切片类型，会追加，非切片覆盖</p>
</blockquote>
</li>
<li>
<p>2.map类型</p>
<blockquote>
<p>只支持键为string，值为基础类型的 map</p>
</blockquote>
</li>
<li>
<p>3.函数类型</p>
</li>
</ul>
<p>编写脚本</p>
<pre><code>package main

import (
	&quot;fmt&quot;
)

type Option struct {
	//特殊类型：基础类型切片、基础类型指针切片、函数、字典
	StrFlag     string         `short:&quot;s&quot; long:&quot;str&quot; description:&quot;string flag value&quot;`
	StrSlice    []string       `long:&quot;strSlice&quot; description:&quot;string slice flag value&quot;`
	PtrStrSlice []*string      `long:&quot;ptrStrSlice&quot; description:&quot;slice of pointer of string flag value&quot;`
	Call        func(string)   `long:&quot;call&quot; description:&quot;callback&quot;`
	IntMap      map[string]int `long:&quot;intMap&quot; description:&quot;a map from string to int&quot;`
}

func main() {
	var opt Option
	//函数类型，需要在 parse之前
	opt.Call = func(s string) {
		fmt.Println(&quot;is callback:&quot;, s)
	}

	flags.parse(&amp;opt)

	//基础类型
	fmt.Println(opt.StrFlag)
	//基础类型切片
	fmt.Println(opt.StrSlice)
	//基础类型指针切片
	for i := 0; i &lt; len(opt.PtrStrSlice); i++ {
		//指针切片，所以追加的是指针。*指针获取具体值
		fmt.Printf(&quot;\t%d: %v\n&quot;, i, *opt.PtrStrSlice[i])
	}
	//字典
	fmt.Printf(&quot;int map:%v\n&quot;, opt.IntMap)
}
</code></pre>
<p>执行</p>
<pre><code>// 基础类型
go run go_flags.go -s test
// 基础类型切片
go run go_flags.go --strSlice test1 --strSlice test2
// 基础类型指针切片
go run go_flags.go --StrSlice test1 --StrSlice test2
// 函数
go run go_flags.go --call test1 --call test2
// 字典
go run go_flags.go --intMap key1:val1 --intMap key2:val2
</code></pre>
<h5 id="2常用设置">2.常用设置</h5>
<blockquote>
<p>required 命令行选项必填<br>
default  默认值</p>
</blockquote>
<pre><code>type Option struct {
	StrFlag string `short:&quot;s&quot; required:&quot;true&quot; default:&quot;test&quot;`
}
</code></pre>
<h5 id="3高级特性">3.高级特性</h5>
<h6 id="1选项分组">1.选项分组</h6>
<blockquote>
<p>group</p>
</blockquote>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/jessevdk/go-flags&quot;
	&quot;log&quot;
	&quot;os&quot;
)

type Option2 struct {
	Basic GroupBasicOption `description:&quot;basis type&quot; group:&quot;basic&quot;`
	Slice GroupSliceOption `description:&quot;slice of basis type&quot; group:&quot;slice&quot;`
}

type GroupBasicOption struct {
	IntFlag  int  `short:&quot;i&quot; long:&quot;intflag&quot; description:&quot;int flag&quot;`
	BoolFlag bool `short:&quot;b&quot; long:&quot;boolflag&quot; description:&quot;bool flag&quot;`
}

type GroupSliceOption struct {
	IntSlice  []int  `long:&quot;intslice&quot; description:&quot;int slice&quot;`
	BoolSlice []bool `long:&quot;bool slice&quot; description:&quot;bool slice&quot;`
}

func main() {
	var opt Option2
	p := flags.NewParser(&amp;opt, flags.Default)
	_, err := p.ParseArgs(os.Args[1:])
	if err != nil {
		log.Fatal(&quot;Parser error&quot;, err)
	}
	//查找分组
	basicGroup := p.Command.Group.Find(&quot;basic&quot;)
	for _, o := range basicGroup.Options() {
		fmt.Printf(&quot;name:%s value:%v\n&quot;, o.LongNameWithNamespace(), o.Value())
	}

	sliceGroup := p.Comand.Group.Find(&quot;slice&quot;)
	for _, o := range sliceGroup.Options() {
		fmt.Printf(&quot;name:%s value:%v\n&quot;, o.LongNameWithNamespace(), o.Value())
	}
}
</code></pre>
<h6 id="2子命令">2.子命令</h6>
<blockquote>
<p>必须实现go-flags定义的Commander接口：</p>
</blockquote>
<pre><code>type Commander interface {
    Execute(args []string) error
}
</code></pre>
<blockquote>
<p>command再定义实现接口的命令为子命令</p>
</blockquote>
<pre><code>package main

import (
	&quot;errors&quot;
	&quot;github.com/jessevdk/go-flags&quot;
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
)

type MathCommand struct {
	Op string `long:&quot;op&quot; description:&quot;operate to execute&quot;`
	Args []string
	Result int64
}
//子命令必须实现go-flags定义的Commander接口：Execute
func (this *MathCommand) Execute(args []string) error  {
	//命令解析时，遇到不是以-或--开头的参数，尝试将其解释为子命令名
	//加、减、乘、除
	if this.op != &quot;+&quot; &amp;&amp; this.op != &quot;-&quot; &amp;&amp; this.op != &quot;x&quot; &amp;&amp; this.op != &quot;/&quot; {
		return errors.New(&quot;invalid op&quot;)
	}

	//子命令后边参数为子命令的参数
	for _, arg := range args {
		num, err := strconv.ParseInt(arg, 10, 64)
		if err != nil {
			return err
		}

		this.Result += num
	}
	this.Args = args
	return nil
}

type Option3 struct {
	//定义子命令 op
	Math MathCommand `command:&quot;math&quot;`
}

func main()  {
	var opt Option3
	_, err := flags.Parse(&amp;opt)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf(&quot;the result of %s is %d&quot;, strings.Join(opt.Math.Args, opt.Math.Op), opt.Math.Result)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-13.解析命令行选项-flag]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-13jie-xi-ming-ling-xing-xuan-xiang-flag/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-13jie-xi-ming-ling-xing-xuan-xiang-flag/">
        </link>
        <updated>2021-10-12T03:14:46.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<p><a href="https://zhuanlan.zhihu.com/p/102576818">Go 每日一库之 flag</a></p>
<blockquote>
<p>（标准库，简单实用）</p>
</blockquote>
<h4 id="1快速开始">1.快速开始</h4>
<p>1.编写测试文件 flag.go</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var (
	intflag int
	boolflag bool
	stringflag string
)

func init()  {
	//flag.TypeVar 定义全局变量，存储命令行选项
	//Type 为基本数据类型、时间间隔time.Duration
	//参数：变量地址、命令行选项名、默认值、-h帮助信息；
	flag.IntVar(&amp;intflag, &quot;initflag&quot;, 1, &quot;int flag value&quot;)
	flag.BoolVar(&amp;boolflag, &quot;boolflag&quot;, false, &quot;bool flag value&quot;)
	flag.StringVar(&amp;stringflag, &quot;stringflag&quot;, &quot;&quot;, &quot;string flag value&quot;)
}

func main(){
	//必须在所有选项都定义之后调用，调用之后不能再定义选项
	//从os.Args[1:]中解析选项
	flag.Parse()

	fmt.Println(&quot;intfalg is:&quot;, intflag)
	fmt.Println(&quot;boolflag is:&quot;, boolflag)
	fmt.Println(&quot;stringflag is:&quot;, stringflag)
}
</code></pre>
<p>2.执行</p>
<pre><code># 查看帮助信息
go run flag.go -h
# 使用
go run flag.go -boolflag true
</code></pre>
<h4 id="2选项格式">2.选项格式</h4>
<blockquote>
<ul>
<li>和 -- 都可以。-表示短选项，--表示长选项。flag不区分</li>
</ul>
</blockquote>
<pre><code>-flag   //只支持布尔型
-flag x //不支持布尔型。因此样式的布尔型在类 Unix 系统中可能会出现意想不到的行为
-flag=x
</code></pre>
<p>1.遇到第一个非选项参数（即不是以-和--开头的）或终止符--，解析停止</p>
<pre><code># 非选项参数a，解析终止
go run flag.go a -boolflag true
# 终止符--，解析终止
go run flag.go -- -boolflag true
</code></pre>
<p>2.解析终止后的命令行参数，flag会保存下来</p>
<pre><code># 修改上述main函数
********
func main(){
	//必须在所有选项都定义之后调用，调用之后不能再定义选项
	//从os.Args[1:]中解析选项
	flag.Parse()

	//解析终止后，flag会保存后续的命令行参数
	//flag.NArg()：后续参数个数
	//flag.Arg(i)：获取后续第i个参数（参数名或值）
	for i := 0; i &lt; flag.NArg(); i++ {
		fmt.Printf(&quot;Argument %d: %s\n&quot;, i, flag.Arg(i))
	}
	//flag.Args()：后续参数的切片
	fmt.Println(flag.Args())
	for j, val := range flag.Args(){
		fmt.Printf(&quot;Argument %d: %s\n&quot;, j, val)
	}
}
********
</code></pre>
<p>执行</p>
<pre><code>go run flag.go -- -boolflag true --stringflag aa
</code></pre>
<h4 id="3定义选项方式2">3.定义选项方式2</h4>
<ul>
<li>1.flag.TypeVar：需要先定义变量</li>
<li>2.flag.Type：自动分配变量，返回该变量地址</li>
</ul>
<pre><code># 与上一种方式基本类似
package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var (
	intflag *int
	boolflag *bool
	stringflag *string
)

func init()  {
	//flag.Type：自动分配变量，返回该变量的地址。需要接收参数
	intflag = flag.Int(&quot;initflag&quot;, 1, &quot;int flag value&quot;)
	boolflag = flag.Bool(&quot;boolflag&quot;, false, &quot;bool flag value&quot;)
	stringflag =flag.String(&quot;stringflag&quot;, &quot;&quot;, &quot;string flag value&quot;)
}

func main(){
	//必须在所有选项都定义之后调用，调用之后不能再定义选项
	//从os.Args[1:]中解析选项
	flag.Parse()

	fmt.Println(&quot;intfalg is:&quot;, *intflag)
	fmt.Println(&quot;boolflag is:&quot;, *boolflag)
	fmt.Println(&quot;stringflag is:&quot;, *stringflag)
}
</code></pre>
<h4 id="4定义短选项">4.定义短选项</h4>
<blockquote>
<p>没有显示支持短选项，可以通过两个选项共享同一个变量实现</p>
</blockquote>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
)

var longLevel string

func init()  {
	const (
		defaultValue = &quot;a&quot;
		usage = &quot;set longType value&quot;
	)

	//两个选项共享同一个变量
	//注意是：长选项与短选项（2个选项具有相同意义）
	//而不是短标识选项 l（短标识只需要定义一次就行）
	flag.StringVar(&amp;longLevel,&quot;long_type&quot;, defaultValue, usage)
	flag.StringVar(&amp;longLevel,&quot;l&quot;, defaultValue, usage + &quot;short link&quot;)
}

func main()  {
	flag.Parse()

	fmt.Println(&quot;log level is:&quot;, longLevel)
}
</code></pre>
<p>执行</p>
<pre><code>go run flag_short_link.go -l test
go run flag_short_link.go -long_type test
</code></pre>
<h4 id="5解析时间间隔">5.解析时间间隔</h4>
<blockquote>
<p>还支持time.Duration类型：时间间隔<br>
格式：ns/us/ms/s/m/h/day 等。例&quot;300ms&quot;、&quot;-1.5h&quot;、&quot;2h45m&quot;</p>
</blockquote>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

var period time.Duration

func init()  {
	flag.DurationVar(&amp;period,&quot;period&quot;, 1*time.Second, &quot;sleep period&quot;)
}

func main()  {
	flag.Parse()

	fmt.Printf(&quot;start sleep period %d\n&quot;, period)
	time.Sleep(period)
	fmt.Printf(&quot;sleep end\n&quot;)
}
</code></pre>
<p>执行</p>
<pre><code>go run flag_time.go 
go run flag_time.go -period 1m30s
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-12.go mod]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-12go-mod/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-12go-mod/">
        </link>
        <updated>2021-10-12T03:13:50.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="问题">问题</h3>
<p>1.Go Module 存在的意义与解决的问题<br>
2.如何维护 module 模式的代码</p>
<h3 id="1go的2种模式">1.go的2种模式</h3>
<p>####1.环境变量 GO111MODULE</p>
<ul>
<li>
<p>1.off：GOPATH模式</p>
<blockquote>
<p>在vendor目录下和GOPATH目录中查找依赖包</p>
</blockquote>
</li>
<li>
<p>2.on：modules模式</p>
<blockquote>
<p>go命令行会使用modules功能，而不会访问GOPATH<br>
GOPATH不再在build时扮演导入的角色，但仍会存储下载依赖包，目录：GOPATH/pkg/mod</p>
</blockquote>
</li>
<li>
<p>3.auto：默认模式</p>
<blockquote>
<p>当前目录在GOPATH/src目录之外；且当前目录或其子目录包含go.mod文件，会启动 modules模式</p>
</blockquote>
</li>
</ul>
<h4 id="2go-module-存在的意义与解决的问题">2.Go Module 存在的意义与解决的问题</h4>
<blockquote>
<p>1.解决只能在 GOPATH 指定路径开发<br>
2.实现有效的版本管理<br>
3.支持 Go 原生工具集依赖管理。</p>
</blockquote>
<p><a href="https://studygolang.com/articles/23964?fr=sidebar">Go Module 存在的意义与解决的问题</a></p>
<h3 id="2go-modulegolang包管理工具">2.Go module（Golang包管理工具）</h3>
<blockquote>
<p>使用go mod 管理项目，就不需要非得把项目放到GOPATH指定目录下；<br>
可以在磁盘的任何位置新建一个项目，且需要在目录下创建一个go.mod文件</p>
</blockquote>
<p><a href="https://blog.csdn.net/benben_2015/article/details/82227338">Go module的介绍及使用</a></p>
<h4 id="1gomod文件">1.go.mod文件</h4>
<blockquote>
<p>1.定义<code>模块路径</code>(命名空间)<br>
2.require：引入 build 时依赖模块（包）及特定版本<br>
3.exclude：排除某些包的特别版本<br>
4.replace：取代当前项目中的某些依赖包</p>
</blockquote>
<pre><code>// 模块路径(命名空间)
module webMerticMonitor

go 1.12

require (
	github.com/Shopify/sarama v1.19.0
	github.com/fortytw2/leaktest v1.3.0 // indirect
	github.com/mailru/easyjson v0.7.6 // indirect
	github.com/olivere/elastic v6.2.34+incompatible
	github.com/spf13/viper v1.7.1
	golang.org/x/sys v0.0.0-20200116001909-b77594299b42 // indirect
	gopkg.in/yaml.v2 v2.2.8 // indirect
)

replace (
	julive v0.0.0-00010101000000-000000000000 =&gt; ../lib
)

</code></pre>
<p><strong>注：go.mod文件用//注释，而不用/**/</strong></p>
<h4 id="2mod对其它命令支持">2.mod对其它命令支持</h4>
<p>1.go build -mod [mode]</p>
<blockquote>
<p>mode有以下几种取值：readonly，release，vendor。</p>
</blockquote>
<pre><code># 例：生成可执行文件，并将项目的依赖包放到主模块的vendor目录下
go build -mod=vendor
</code></pre>
<p>2.go get -m [packages]</p>
<blockquote>
<p>下载依赖包到GOPATH/pkg/mod目录,并且将依赖写入到go.mod文件</p>
</blockquote>
<h4 id="3go-mod命令">3.go mod命令</h4>
<h5 id="1go-mod-download">1.go mod download</h5>
<blockquote>
<p>预填充本地缓存</p>
</blockquote>
<p>用法：go mod download [-dir] [-json] [modules]</p>
<blockquote>
<p>下载指定的模块[modules]<br>
没有指定参数，将主模块下的所有依赖下载下来</p>
</blockquote>
<h5 id="2go-mod-init">2.go mod init</h5>
<blockquote>
<p>在当前目录中初始化和创建一个新的go.mod文件</p>
</blockquote>
<p>用法：go mod init [module]</p>
<blockquote>
<p>[module]：模块名（命名空间）</p>
</blockquote>
<p><strong>注1：使用这条命令时，go.mod文件必须提前不能存在</strong><br>
<strong>注2：在 main.go 里如果需要使用项目内的包，需要使用这个包的<code>模块内的绝对路径</code>（命名空间）来导入</strong></p>
<h5 id="3go-mod-tidy">3.go mod tidy</h5>
<blockquote>
<p>添加缺失的模块以及移除不需要的模块</p>
</blockquote>
<p>用法：go mod tidy [-v]</p>
<h6 id="1错误dial-tcp-17221727145443-io-timeout">1.错误：dial tcp 172.217.27.145:443: i/o timeout</h6>
<blockquote>
<p>国内把mod墙，需要设置代理GOPROXY到环境变量</p>
</blockquote>
<pre><code>vi ~/.bash_profile
******
export GOPROXY=https://goproxy.cn,direct
export GO111MODULE=on
******

source ~/.bash_profile
</code></pre>
<pre><code>dial tcp 172.217.27.145:443: i/o timeout
</code></pre>
<h6 id="2注意启用-go-module后依赖包下载位置">2.注意：启用 go module后，依赖包下载位置</h6>
<blockquote>
<p><code>启用 go module：</code>env 中配置 GO111MODULE 为 on或 auto；<br>
<code>下载依赖包目录：</code>不管go get 或 go mod tidy 等都会下载到固定目录：$GOPATH/pkg/mod，并且目录名里的大写字母会转成小写字母 , 前面加一个!</p>
</blockquote>
<h5 id="4go-mod-vendor">4.go mod vendor</h5>
<blockquote>
<p>将build阶段需要的所有依赖包放到主模块所在的vendor目录中</p>
</blockquote>
<p>用法：go mod vendor [-v]</p>
<h5 id="5go-mod-verify">5.go mod verify</h5>
<blockquote>
<p>1.检查当前模块的依赖是否已经存储在本地下载的源代码缓存中（GOPATH/pkg/mod）；<br>
2.检查自从下载下来是否有修改；<br>
3.如果所有的模块都没有修改，那么会打印 all modules verified</p>
</blockquote>
<pre><code># 例子
module webMerticMonitor

go 1.12

require (
	github.com/Shopify/sarama v1.19.0
	github.com/fortytw2/leaktest v1.3.0 // indirect
	github.com/mailru/easyjson v0.7.6 // indirect
	github.com/olivere/elastic v6.2.34+incompatible
	github.com/spf13/viper v1.7.1
	golang.org/x/sys v0.0.0-20200116001909-b77594299b42 // indirect
	gopkg.in/yaml.v2 v2.2.8 // indirect
	julive v0.0.0-00010101000000-000000000000
)

replace julive =&gt; ../lib
</code></pre>
<p>校验</p>
<pre><code>go mod verify
# julive v0.0.0-00010101000000-000000000000: missing ziphash: open hash: no such file or directory
</code></pre>
<p>修改mod文件：严格遵守 require,replace</p>
<pre><code>module webMerticMonitor

go 1.12

require (
	github.com/Shopify/sarama v1.19.0
	github.com/fortytw2/leaktest v1.3.0 // indirect
	github.com/mailru/easyjson v0.7.6 // indirect
	github.com/olivere/elastic v6.2.34+incompatible
	github.com/spf13/viper v1.7.1
	golang.org/x/sys v0.0.0-20200116001909-b77594299b42 // indirect
	gopkg.in/yaml.v2 v2.2.8 // indirect
)

replace (
	julive v0.0.0-00010101000000-000000000000 =&gt; ../lib
)
</code></pre>
<p>校验</p>
<pre><code>go mod verify
# all modules verified
</code></pre>
<h3 id="3goland-导入包含-mod-项目">3.goland 导入包含 mod 项目</h3>
<h4 id="1gopath方式">1.GOPATH方式</h4>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210114182534.png" alt="" loading="lazy"></figure>
<h4 id="2module方式">2.module方式</h4>
<p>1.导入项目<br>
<img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210114183306.png" alt="" loading="lazy"></p>
<p>2.main 中导入的包找不到的(即使本地gopath路径下有)<br>
<img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210114181911.png" alt="" loading="lazy"></p>
<p>3.使用alt+Enter 就是goland传统的导入包的方式 或者 go mod download，<br>
<img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210114183737.png" alt="" loading="lazy"></p>
<h3 id="4gopath切换到go-mod">4.GOPATH切换到go mod</h3>
<blockquote>
<p>其它包管理方式：GOPATH,GOVENDOR,...都可以通过下列方式切换到 go mod</p>
</blockquote>
<pre><code># 1.初始化，生成 go mod 文件
go mod init [mode]

# 2.通过编译目录及子目录所有文件，下载所有依赖包
go build ./...
# 生成的可执行文件，看不到，可以通过下列方式，在 src/bin 中找到
go install ./...
</code></pre>
<h3 id="5依赖包可视化-gmchart">5.依赖包可视化 gmchart</h3>
<blockquote>
<p>检索 Go Module 依赖关系 可视化</p>
</blockquote>
<p><a href="https://studygolang.com/articles/32776#reply0">go mod graph 可视化——gmchart</a><br>
<a href="https://github.com/PaulXu-cn/go-mod-graph-chart">github-gmchart</a></p>
<h4 id="1安装">1.安装</h4>
<pre><code># 安装包 gmchart
go get -u github.com/PaulXu-cn/go-mod-graph-chart/gmchart
</code></pre>
<h4 id="2使用">2.使用</h4>
<pre><code># 注：如果不可用，确认 $GOPATH 是否已经失效，导致 gmchart 安装位置失效
cd goProject
go mod graph | gmchart
</code></pre>
<p>浏览器会自动打开新页面，展示包依赖关系</p>
<blockquote>
<p>如果没有，手动打开浏览器 <code>http://127.0.0.1:60306/</code></p>
</blockquote>
<h3 id="6错误">6.错误</h3>
<h4 id="1dial-tcp-216239371443-io-timeout">1.dial tcp 216.239.37.1:443: i/o timeout</h4>
<blockquote>
<p>go get或go mod时都可能产生此错误，原因是墙。需要设置代理，并开启go mod支持</p>
</blockquote>
<pre><code>go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>
<h4 id="2dial-tcp-216239371443-connectex-a-connection-attempt-failed">2.dial tcp 216.239.37.1:443: connectex: A connection attempt failed</h4>
<blockquote>
<p>关闭环境变量 GOSUMDB。默认是sum.golang.org</p>
</blockquote>
<pre><code>go env -w GOSUMDB=off
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-11.数据库操作]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-11shu-ju-ku-cao-zuo/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-11shu-ju-ku-cao-zuo/">
        </link>
        <updated>2021-10-12T03:13:08.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1文献">1.文献</h3>
<p><a href="http://gorm.book.jasperxu.com/">gorm v1中文文档</a><br>
<a href="https://www.kancloud.cn/sliver_horn/gorm/1861152">gorm v2中文文档</a></p>
<h3 id="2入门">2.入门</h3>
<h4 id="1特性">1.特性</h4>
<ul>
<li>全功能 ORM</li>
<li>关联 (Has One、Has Many、Belongs To、Many To Many、多态、单表继承)</li>
<li>Create、Save、Update、Delete、Find 前/后的勾子</li>
<li>基于Preload、Joins的预加载</li>
<li>事务、嵌套事务、保存点、回滚至保存点</li>
<li>Context、Prepared Statment 模式、DryRun 模式</li>
<li>批量插入、FindInBatches、查询至 Map</li>
<li>SQL Builder, Upsert, Locking, Optimizer/Index/Comment Hints</li>
<li>复合主键</li>
<li>自动迁移</li>
<li>自定义 Logger</li>
<li>灵活的可扩展插件 API：Database Resolver（读写分离）、Prometheus…</li>
<li>所有特性都通过了测试</li>
<li>开发者友好</li>
</ul>
<h4 id="2安装">2.安装</h4>
<pre><code># 安装gorm包 &amp; mysql驱动包
go get -v -u github.com/jinzhu/gorm
go get -v -u github.com/go-sql-driver/mysql
</code></pre>
<ul>
<li>go get</li>
</ul>
<blockquote>
<p>借助代码管理工具通过远程拉取或更新代码包及其依赖包，并自动完成编译和安装<br>
-v 显示操作流程的日志及信息，方便检查错误<br>
-u 下载丢失的包，但不会更新已经存在的包</p>
</blockquote>
<h4 id="3快速入门">3.快速入门</h4>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/jinzhu/gorm&quot;
	_&quot;github.com/go-sql-driver/mysql&quot;
)

type TestUser struct {
	gorm.Model
	Name string
	Age int
}

func main()  {
	// &lt;user&gt;:&lt;password&gt;@(host:port)/&lt;database&gt;?charset=utf8mb4&amp;parseTime=True&amp;loc=Local
	db, err := gorm.Open(&quot;mysql&quot;, &quot;comjia002_wukong:Je6Quo!jei-ph9Esfo$iFee2@(127.0.0.1:33060)/comjia_merge?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;)
	if err != nil {
		fmt.Printf(&quot;数据库连接失败:%v&quot;, err)
	}

	//自动迁移数据结构（创建表）
	db.AutoMigrate(&amp;TestUser{})
	//新增记录
    user := TestUser{Name:&quot;张三&quot;, Age:20}
	result := db.Create(&amp;user)
	fmt.Printf(&quot;新增记录id %v \n&quot;, user.ID)
	fmt.Printf(&quot;新增记录行数 %v \n&quot;, result.RowsAffected)
}
</code></pre>
<h4 id="3声明模型">3.声明模型</h4>
<h5 id="1约定">1.约定</h5>
<blockquote>
<p>1.默认情况下，GORM 使用 ID 作为主键，使用结构体名的 <code>蛇形复数</code> 作为表名，字段名的 <code>蛇形</code> 作为列名；<br>
2.并使用 CreatedAt、UpdatedAt 字段追踪创建、更新时间</p>
</blockquote>
<h5 id="2gormmodel">2.gorm.Model</h5>
<pre><code>// GORM 定义一个 gorm.Model 结构体
type Model struct {
  ID        uint           `gorm:&quot;primaryKey&quot;`
  CreatedAt time.Time
  UpdatedAt time.Time
  DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`
}
</code></pre>
<p>遵循 GORM 已有的约定，可以减少您的配置和代码量</p>
<pre><code>type User struct {
  gorm.Model
  Name string
}
// 等效于
type User struct {
  ID        uint           `gorm:&quot;primaryKey&quot;`
  CreatedAt time.Time
  UpdatedAt time.Time
  DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`
  Name string
}
</code></pre>
<h5 id="3字段控制结构体标签">3.字段控制：结构体标签</h5>
<p><code>结构体标签</code>：通过结构体标签，可以设置索引、字段默认值、字段权限控制、嵌入结构体 等等</p>
<pre><code>type User struct {
  //索引
  ID        uint           `gorm:&quot;primaryKey&quot;`
  DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`
  
  //字段权限控制
  Name string `gorm:&quot;&lt;-:create&quot;` // 允许读和创建
  Name string `gorm:&quot;&lt;-:update&quot;` // 允许读和更新
  Name string `gorm:&quot;&lt;-&quot;`        // 允许读和写（创建和更新）
  Name string `gorm:&quot;&lt;-:false&quot;`  // 允许读，禁止写
  Name string `gorm:&quot;-&gt;&quot;`        // 只读（除非有自定义配置，否则禁止写）
  Name string `gorm:&quot;-&gt;;&lt;-:create&quot;` // 允许读和写
  Name string `gorm:&quot;-&gt;:false;&lt;-:create&quot;` // 仅创建（禁止从 db 读）
  Name string `gorm:&quot;-&quot;`  // 读写操作均会忽略该字段
  
  //默认值
  Age       int64  `gorm:&quot;default:18&quot;`
  Updated   int64 `gorm:&quot;autoUpdateTime:nano&quot;` // 使用纳秒级时间戳填充更新时间
  Updated   int64 `gorm:&quot;autoUpdateTime:milli&quot;` // 使用毫秒级时间戳填充更新时间
  Created   int64 `gorm:&quot;autoCreateTime&quot;`      // 使用秒级时间戳填充创建时间
}
</code></pre>
<h5 id="4嵌入结构体embedded">4.嵌入结构体：embedded</h5>
<pre><code>// 1.匿名字段
type User struct {
  gorm.Model
  Name string
}

// 2.通过标签：embedded，嵌入正常结构体字段
type Author struct {
  Name  string
  Email string
}

type Blog struct {
  ID      int
  Author  Author `gorm:&quot;embedded&quot;`
  Upvotes int32
}
// 等效于
type Blog struct {
  ID    int64
  Name  string
  Email string
  Upvotes  int32
}
</code></pre>
<p>embeddrefix:为索引嵌入的字段添加统一前缀</p>
<pre><code>type Blog struct {
  ID      int
  Author  Author `gorm:&quot;embedded;embeddedPrefix:author_&quot;`
  Upvotes int32
}
// 等效于
type Blog struct {
  ID          int64
  AuthorName  string
  AuthorEmail string
  Upvotes     int32
}
</code></pre>
<h4 id="4连接数据库">4.连接数据库</h4>
<h5 id="1mysql">1.mysql</h5>
<pre><code>import (
  &quot;gorm.io/driver/mysql&quot;
  &quot;gorm.io/gorm&quot;
)

func main() {
  // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情
  dsn := &quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;
  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
}
</code></pre>
<p>注：</p>
<ul>
<li>想要 Gorm 正确的处理 time.Time ，您需要带上 parseTime 参数</li>
<li>想要支持完整的 UTF-8 编码，您需要将 charset=utf8 更改为 charset=utf8mb4</li>
</ul>
<h5 id="2postgresql">2.PostgreSQL</h5>
<pre><code>import (
  &quot;gorm.io/driver/postgres&quot;
  &quot;gorm.io/gorm&quot;
)

dsn := &quot;user=gorm password=gorm dbname=gorm port=9920 sslmode=disable TimeZone=Asia/Shanghai&quot;
db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
</code></pre>
<h5 id="3sqlite">3.SQLite</h5>
<pre><code>import (
  &quot;gorm.io/driver/sqlite&quot;
  &quot;gorm.io/gorm&quot;
)

// github.com/mattn/go-sqlite3
db, err := gorm.Open(sqlite.Open(&quot;gorm.db&quot;), &amp;gorm.Config{})
</code></pre>
<h5 id="4sql-server">4.SQL Server</h5>
<pre><code>import (
  &quot;gorm.io/driver/sqlserver&quot;
  &quot;gorm.io/gorm&quot;
)

// github.com/denisenkom/go-mssqldb
dsn := &quot;sqlserver://gorm:LoremIpsum86@localhost:9930?database=gorm&quot;
db, err := gorm.Open(sqlserver.Open(dsn), &amp;gorm.Config{})
</code></pre>
<h3 id="3curd">3.CURD</h3>
<h4 id="1新增">1.新增</h4>
<pre><code>//自动迁移数据结构（创建表）
db.AutoMigrate(&amp;TestUser{})

//单行插入
user := TestUser{Name:&quot;张三&quot;, Age:20}
result := db.Create(&amp;user)
fmt.Printf(&quot;单行新增记录id %v \n&quot;, user.ID)
fmt.Printf(&quot;单行新增记录行数 %v \n&quot;, result.RowsAffected)

//Select(&quot;column&quot;) 查询字段
//Omit(&quot;column&quot;)   排出字段
</code></pre>
<h4 id="2查询">2.查询</h4>
<ul>
<li>查询函数</li>
</ul>
<pre><code>// 获取全部记录
result := db.Find(&amp;users)
// SELECT * FROM users;

// 获取第一条记录（主键升序）
db.First(&amp;user)
// SELECT * FROM users ORDER BY id LIMIT 1;

// 获取一条记录，没有指定排序字段
db.Take(&amp;user)
// SELECT * FROM users LIMIT 1;

// 获取最后一条记录（主键降序）
db.Last(&amp;user)
// SELECT * FROM users ORDER BY id DESC LIMIT 1;

result := db.First(&amp;user)
result.RowsAffected // 返回找到的记录数
result.Error        // returns error

// 检查 ErrRecordNotFound 错误
errors.Is(result.Error, gorm.ErrRecordNotFound)
</code></pre>
<ul>
<li>where条件</li>
</ul>
<pre><code>// 获取第一条匹配的记录
db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;user)
// SELECT * FROM users WHERE name = 'jinzhu' ORDER BY id LIMIT 1;

// 获取全部匹配的记录
db.Where(&quot;name &lt;&gt; ?&quot;, &quot;jinzhu&quot;).Find(&amp;users)
// SELECT * FROM users WHERE name &lt;&gt; 'jinzhu';

// IN
db.Where(&quot;name IN ?&quot;, []string{&quot;jinzhu&quot;, &quot;jinzhu 2&quot;}).Find(&amp;users)
// SELECT * FROM users WHERE name in ('jinzhu','jinzhu 2');

// LIKE
db.Where(&quot;name LIKE ?&quot;, &quot;%jin%&quot;).Find(&amp;users)
// SELECT * FROM users WHERE name LIKE '%jin%';

// AND
db.Where(&quot;name = ? AND age &gt;= ?&quot;, &quot;jinzhu&quot;, &quot;22&quot;).Find(&amp;users)
// SELECT * FROM users WHERE name = 'jinzhu' AND age &gt;= 22;

// Time
db.Where(&quot;updated_at &gt; ?&quot;, lastWeek).Find(&amp;users)
// SELECT * FROM users WHERE updated_at &gt; '2000-01-01 00:00:00';

// BETWEEN
db.Where(&quot;created_at BETWEEN ? AND ?&quot;, lastWeek, today).Find(&amp;users)
// SELECT * FROM users WHERE created_at BETWEEN '2000-01-01 00:00:00' AND '2000-01-08 00:00:00';
</code></pre>
<ul>
<li>Struct &amp; Map 条件</li>
</ul>
<pre><code>// Struct
db.Where(&amp;User{Name: &quot;jinzhu&quot;, Age: 20}).First(&amp;user)
// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 ORDER BY id LIMIT 1;

// Map
db.Where(map[string]interface{}{&quot;name&quot;: &quot;jinzhu&quot;, &quot;age&quot;: 20}).Find(&amp;users)
// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;

// 主键切片条件
db.Where([]int64{20, 21, 22}).Find(&amp;users)
// SELECT * FROM users WHERE id IN (20, 21, 22);
</code></pre>
<p>注：</p>
<ul>
<li>结构作为条件查询时，GORM 只会查询非零值字段</li>
<li>字典，零值字段仍会作为查询条件</li>
</ul>
<h4 id="3更新">3.更新</h4>
<ul>
<li>save</li>
</ul>
<pre><code>db.First(&amp;user)

user.Name = &quot;jinzhu 2&quot;
user.Age = 100
db.Save(&amp;user)
// UPDATE users SET name='jinzhu 2', age=100, birthday='2016-01-01', updated_at = '2013-11-17 21:34:10' WHERE id=111;
</code></pre>
<ul>
<li>Update/Updates</li>
</ul>
<pre><code>// 更新单个字段
// the user of `Model(&amp;user)` needs to have primary key value, it is `111` in this example
db.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)
// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111;

// 根据条件更新单个字段
db.Model(&amp;user).Where(&quot;active = ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)
// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111 AND active=true;

// 通过 `struct` 更新多个字段，不会更新零值字段
db.Model(&amp;user).Updates(User{Name: &quot;hello&quot;, Age: 18, Active: false})
// UPDATE users SET name='hello', age=18, updated_at = '2013-11-17 21:34:10' WHERE id = 111;

// 通过 `map` 更新多个字段，零值字段也会更新
db.Model(&amp;user).Updates(map[string]interface{}{&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;actived&quot;: false})
// UPDATE users SET name='hello', age=18, actived=false, updated_at='2013-11-17 21:34:10' WHERE id=111;
</code></pre>
<h4 id="4删除">4.删除</h4>
<pre><code>// 删除一条已有的记录（email 的主键值为 10）
db.Delete(&amp;email)
// DELETE from emails where id=10;

// 通过内联条件删除记录
db.Delete(&amp;Email{}, 20)
// DELETE from emails where id=20;

// 带上其它条件
db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Delete(&amp;email)
// DELETE FROM emails WHERE id=10 AND name = 'jinzhu'
</code></pre>
<h4 id="5原生sql">5.原生sql</h4>
<ul>
<li>原生 SQL 查询</li>
</ul>
<pre><code>type Result struct {
  ID   int
  Name string
  Age  int
}

var result Result
db.Raw(&quot;SELECT id, name, age FROM users WHERE name = ?&quot;, 3).Scan(&amp;result)

var age int
DB.Raw(&quot;select sum(age) from users where role = ?&quot;, &quot;admin&quot;).Scan(&amp;age)
</code></pre>
<ul>
<li>2.执行原生 SQL</li>
</ul>
<pre><code>db.Exec(&quot;DROP TABLE users&quot;)
db.Exec(&quot;UPDATE orders SET shipped_at=? WHERE id IN ?&quot;, time.Now(), []int64{1,2,3})

// SQL 表达式
DB.Exec(&quot;update users set money=? where name = ?&quot;, gorm.Expr(&quot;money * ? + ?&quot;, 10000, 1), &quot;jinzhu&quot;)
</code></pre>
]]></content>
    </entry>
</feed>