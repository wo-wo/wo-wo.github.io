<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wo-wo.github.io</id>
    <title>石强博客</title>
    <updated>2021-10-20T12:21:59.499Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wo-wo.github.io"/>
    <link rel="self" href="https://wo-wo.github.io/atom.xml"/>
    <subtitle>勤学如春起之苗，不见其增，日有所长&lt;br&gt;
辍学如磨刀之秋，不见其损，日有所亏</subtitle>
    <logo>https://wo-wo.github.io/images/avatar.png</logo>
    <icon>https://wo-wo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 石强博客</rights>
    <entry>
        <title type="html"><![CDATA[博客工具选择]]></title>
        <id>https://wo-wo.github.io/post/bo-ke-gong-ju-xuan-ze/</id>
        <link href="https://wo-wo.github.io/post/bo-ke-gong-ju-xuan-ze/">
        </link>
        <updated>2021-10-19T14:27:20.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1在线文字平台">1.在线文字平台</h3>
<h4 id="1语雀">1.语雀</h4>
<p><a href="https://www.yuque.com/">官网</a></p>
<blockquote>
<p>优雅高效的在线文档编辑与协同工具；孵化自 蚂蚁金服<br>
支持富文本 及 Markdown，且对后者做了优化<br>
额外有注入查找替换、翻译、大纲等功能</p>
</blockquote>
<p>结论：撰写文档，这将是一个非常棒的平台</p>
<h4 id="2思否">2.思否</h4>
<p><a href="https://segmentfault.com/">官网</a></p>
<blockquote>
<p>中国领先的开发者技术社区；最像 Stack Overflow；<br>
非常推荐各种开发者加以利用 &amp; 贡献；</p>
</blockquote>
<p>结论：更推荐在自己的平台写，同步一份链接发到头条，一来分享，二来为自己平台导流，也不担心 SEO 副作用</p>
<h4 id="3简书">3.简书</h4>
<p><a href="https://www.jianshu.com/">简书</a></p>
<blockquote>
<p>早起，文青范儿中透漏着些许创新；<br>
而今“鸡汤文遍野，标题党横行”</p>
</blockquote>
<p>结论：鲜有好文，环境若此，不用也罢</p>
<h4 id="4博客园">4.博客园</h4>
<p><a href="https://www.cnblogs.com/">官网</a></p>
<blockquote>
<p>面向开发者的知识分享社区；<br>
虽支持 Markdown，但使用体验仍止步不前，多少有些不思上进的味道；<br>
不过，索性运营仍是不改初心，至今，仍会有很多不错的文章，其知名度已不复当年</p>
</blockquote>
<p>结论：写了好文，可同步一份至该平台，分享 &amp; 引流</p>
<h4 id="5掘金">5.掘金</h4>
<p><a href="https://juejin.cn/">官网</a></p>
<blockquote>
<p>帮助开发者成长的社区；<br>
平台大了，拉低社区的质量，如今文章质量参差不齐，且日渐走低；<br>
鉴于掘金已将其 SEO 优化已至化境，已不建议同步文章至该平台，以防稀释自己主平台搜索点击量</p>
</blockquote>
<p>结论：不建议同步文章至该平台，以防稀释自己主平台搜索点击量</p>
<h4 id="6知乎">6.知乎</h4>
<p><a href="https://www.zhihu.com/">官网</a></p>
<blockquote>
<p>中文互联网最大的知识平台；<br>
Markdown 支持不友好；<br>
如今的知乎，与掘金如出一辙；</p>
</blockquote>
<p>结论：偶尔看看，不建议写</p>
<h4 id="总结">总结</h4>
<ul>
<li>撰写文档，语雀；</li>
<li>技术社区，思否；</li>
<li>引流，思否、博客园；</li>
</ul>
<h3 id="2静态独立博客工具">2.静态独立博客工具</h3>
<h4 id="1hexo">1.Hexo</h4>
<p><a href="https://hexo.io/zh-cn/">官网</a></p>
<blockquote>
<p>Node.js 提供支持的快速，简单且功能强大的博客框架<br>
超快速度、一键部署、支持 Markdown、插件丰富<br>
主题非常丰富，可以与WordPress媲美</p>
</blockquote>
<p>结论：产品成熟，使用简单，功能强大；<br>
但像发布后台、站内搜索，评论系统类似诉求，虽然有对应的工具，但也需要自己折腾下</p>
<h4 id="2jekyll">2.Jekyll</h4>
<p><a href="http://jekyllcn.com/">官网</a></p>
<blockquote>
<p>将纯文本转换为静态博客网站；<br>
Ruby 提供支持简单、可识别博客的静态站点生成器，非常适合个人；<br>
呈现 Markdown 和 Liquid 模板，并呈现一个完整的静态网站；<br>
是 GitHub Pages 背后的引擎；用它来直接从 GitHub 存储库托管站点；</p>
</blockquote>
<p>结论：中文文档齐全、各种 UI 设计；<br>
跟 Hexo 很相似，非常适合个人组织站点；<br>
基于 Ruby，虽有学习成本，按文档，也可快速搭建</p>
<h4 id="3gitbook">3.Gitbook</h4>
<p><a href="https://www.gitbook.com/">官网</a></p>
<blockquote>
<p>基于 GitHub/Git 和 Markdown（或 AsciiDoc）编写和维护高质量的文档；</p>
</blockquote>
<p>结论：搭建技术文档、编写电子书，不错选择</p>
<h4 id="4vuepress">4.Vuepress</h4>
<p><a href="https://vuepress.vuejs.org/zh/">官网</a></p>
<blockquote>
<p>由 Vue 驱动的静态网站生成器；追求简洁至上；<br>
支持 Markdown；<br>
有非常好的加载性能和搜索引擎优化（SEO）</p>
</blockquote>
<p>结论：针对前端开发者，这个是非常棒的选择</p>
<h4 id="5docz">5.Docz</h4>
<p><a href="https://www.docz.site/">官网</a></p>
<blockquote>
<p>零配置；<br>
基于 MDX( Markdown + JSX )，极大降低组件编写复杂度；</p>
</blockquote>
<p>结论：同 VuePress；<br>
发展不久，相关性插件不足；<br>
构建出来的是 SPA，而 GitHub Pages 本身不支持单页面应用程序（SPA）；</p>
<h4 id="6github-personal-website-generator">6.GitHub personal website generator</h4>
<p><a href="https://github.com/sgvictorino/github-personal-site-generator-result">官网</a></p>
<blockquote>
<p>由 Github 官方出品的个人网站生成器工具；<br>
展示您的贡献、兴趣和开发经验的个人网站；<br>
由 GitHub API，GitHub Pages 和 Jekyll 提供支持</p>
</blockquote>
<p>结论：与 Github 保持同步；使用体验感觉良好；功能过于简单，也没有相关性插件</p>
<h4 id="总结-2">总结</h4>
<ul>
<li>搭建博客，Hexo、Jekyll；</li>
<li>技术文档，Gitbook；</li>
<li>前端开发，Vuepress、Docz；</li>
</ul>
<p>缺点：站内搜索、部署以及评论，都是需要自行搞定，但也比较轻松；</p>
<ul>
<li>站内搜索：Algolia，提供搜索即服务</li>
<li>部署和评论：基于 Github 就好；分别是 Github pages 服务和 Github Issues</li>
</ul>
<h3 id="3支持后台的博客系统">3.支持后台的博客系统</h3>
<h4 id="1wordpress">1.Wordpress</h4>
<p><a href="https://cn.wordpress.org/">官网</a></p>
<blockquote>
<p>基于 php；支持 Docker 搭建<br>
功能强大，插件丰富；<br>
入门使用成本低、但是定制的学习成本高；<br>
Markdown 支持不是很友好；<br>
性能较差；<br>
日益臃肿；</p>
</blockquote>
<p>结论：插件丰富，功能强大，日益臃肿</p>
<h4 id="2ghost">2.Ghost</h4>
<p><a href="https://www.ghostchina.com/">官网</a></p>
<blockquote>
<p>基于 Node.js 构建；<br>
官方提供 Docker 镜像；<br>
支持 Markdown，取代臃肿的 Wordpress；<br>
非常强劲好用的后台；<br>
自定义 Facebook 和 Twitter 的社交媒体共享卡，使您能够为社交媒体添加自定义图像，标题和说明，十分利于 SEO；<br>
部署成本较高；分类功能不行</p>
</blockquote>
<p><a href="https://quickapp.lovejade.cn/ghost-open-source-blog-platform/?utm_source=nicelinks.site">更多功能</a></p>
<p>结论：UI 极具美感，插件丰富；自带强大的后台，可自定义修改；支持多人协作，部署简单；<br>
唯一欠缺的是，在国内使用，需要自行关联评论系统；</p>
<h4 id="3solo">3.Solo</h4>
<p><a href="https://b3log.org/solo/">官网</a></p>
<blockquote>
<p>基于 java 打造；支持 Docker 搭建<br>
功能：评论、置顶、国际化、多用户协作、多端适配、社区同步等；<br>
Hexo / Jekyll / Markdown 导入</p>
</blockquote>
<p>结论：主题欠缺，借鉴了 Ghost 的一些 UI 设计，亦可弥补</p>
<h4 id="4hugo">4.Hugo</h4>
<p><a href="https://www.gohugo.org/">官网</a></p>
<blockquote>
<p>基于 go；<br>
支持 Markdown；</p>
</blockquote>
<p>结论：文档较少，17年后不更新</p>
<h4 id="5gridea">5.Gridea</h4>
<p><a href="https://gridea.dev/">官网</a></p>
<blockquote>
<p>基于 Github pages 服务；不支持 gitee<br>
支持 Markdown；<br>
文件都在你的本地，构建静态网站；<br>
搭建简洁；</p>
</blockquote>
<p>结论：非常简洁；主题优美；客户端完成；<br>
缺点，因 Github 同步时可能出错</p>
<h4 id="6maverick">6.Maverick</h4>
<p><a href="https://sspai.com/post/58013">少数派地址</a></p>
<blockquote>
<p>基于 Github pages，Github action（持续集成）服务；<br>
免费、超快的全球 CDN；<br>
非常简洁；</p>
</blockquote>
<p>结论：非常简洁；持续集成；云端转化完成；</p>
<h4 id="总结-3">总结</h4>
<ul>
<li>有个人服务器，Ghost；</li>
<li>前端开发，VuePress；</li>
<li>剩余，hexo；</li>
</ul>
<p>寄语：</p>
<ul>
<li>能够获得暴利的职业，都有一个共同特点：可扩展性，一次劳动可以服务成千上万的人</li>
<li>软件、电影、游戏行业都具有可扩展性，作品的生产成本是固定的，但可以被消费无数次，所以有巨大的获利空间，创造出许许多多的富豪</li>
<li>写作是最具可扩展性的活动。你呆在家里，不去参加活动、会议，只是在网上写下自己的想法，然后你就具有了最好的可扩展性</li>
</ul>
<h3 id="4附件">4.附件</h3>
<p><a href="https://www.cnblogs.com/jadeboy/p/11306532.html">原文-如何选定搭建个人独立博客工具</a><br>
<a href="https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&amp;mid=2247484398&amp;idx=1&amp;sn=c1d76451247c5906d7921ded632f8383&amp;chksm=9bd0ae76aca72760b3c75e00d94b318707573df5faa50579c294db7e1093c0030bbf5a924032&amp;scene=21#wechat_redirect">博客搭建攻略（一）：平台选择</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用三方工具集]]></title>
        <id>https://wo-wo.github.io/post/chang-yong-san-fang-gong-ju-ji/</id>
        <link href="https://wo-wo.github.io/post/chang-yong-san-fang-gong-ju-ji/">
        </link>
        <updated>2021-10-19T14:25:55.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h2 id="1搜索">1.搜索</h2>
<h3 id="1资料搜索">1.资料搜索</h3>
<p>1.<a href="https://www.chongbuluo.com/">虫部落</a></p>
<blockquote>
<p>搜索知识、技术和经验分享平台<br>
资源丰富，帖子质量高<br>
<a href="https://search.chongbuluo.com/">快搜</a><br>
<a href="http://code.giffox.com/">程序员导航</a>(已失效)</p>
</blockquote>
<h3 id="2云盘">2.云盘</h3>
<p>1.<a href="https://www.wowenda.com/">云网盘之家</a></p>
<blockquote>
<p>Google排名最高，而且主页也很干净<br>
解决：正规搜索引擎搜索资源，打不开或收费（仔细观察这些网页，它们虽然无法下载，但下载路径都指向第三方网盘）</p>
</blockquote>
<p>2.<a href="https://www.soyunpan.com/">搜云盘</a></p>
<p>3.<a href="http://www.kengso.com/s?st=0&amp;wd=%E6%9D%A5%E8%87%AAiphone">百度云搜索</a></p>
<h2 id="2工具箱">2.工具箱</h2>
<p>1.<a href="https://github.com/zhaoolee/OnlineToolsBook">在线工具秘籍</a>（推荐）</p>
<blockquote>
<p>为在线工具写一本优质说明书,让在线工具造福人类<br>
分：工具类、资源类</p>
</blockquote>
<h2 id="3写作">3.写作</h2>
<p>1.<a href="https://www.notion.so/Getting-Started-d20a4a84577d4a35a72abb5872153e0b">Notion</a></p>
<blockquote>
<p>笔记工具：多端同步；个人版免费；工具丰富</p>
</blockquote>
<p><a href="http://www.360doc.com/content/20/1212/14/71982547_951098535.shtml">使用教程</a></p>
<p>2.<a href="https://editor.mdnice.com/">mdnice</a>（推荐）</p>
<blockquote>
<p><a href="https://www.v2fy.com/p/T035-mdnice-2020-09-27/">推荐理由</a><br>
Markdown支持：微信公众号，哔哩哔哩，知乎，掘金发文排版<br>
支持丰富的主题</p>
</blockquote>
<p>3.<a href="https://doocs.gitee.io/md/#/">微信Markdown编辑器</a></p>
<blockquote>
<p><a href="https://doocs.github.io/md/#/">备用地址</a></p>
</blockquote>
<h2 id="4开发">4.开发</h2>
<p>1.<a href="https://github.com/trending">Github趋势榜</a></p>
<blockquote>
<p>了解Github当前最受关注的项目<br>
也经常会出现一些福利项目,比如某互联网公司的源码,或国内某著名搜索公司网盘的破解版,有时候甚至会出现一些颜色网站的爬虫,每日查看Github Trending榜,每日一个超神小技巧</p>
</blockquote>
<p>2.<a href="http://idea.medeming.com/jets/">免费JetBrain全家桶激活码</a></p>
<p>3.<a href="https://www.cxy521.com/">程序员导航</a></p>
<p>4.<a href="https://jwt.io/#debugger-io">jwt在线解析工具</a></p>
<h2 id="5视频-图片">5.视频、图片</h2>
<h3 id="1图片">1.图片</h3>
<p>1.<a href="https://www.pexels.com/zh-cn/">品质最高的免费素材站</a></p>
<p>2.<a href="https://www.todaybing.com/">下载4K画质Bing壁纸</a></p>
<p>3.<a href="https://www.iloveimg.com/zh-cn/compress-image">在线批量无损压缩图片</a></p>
<p>4.<a href="https://renzhezhilu.gitee.io/webp2jpg-online/">图片尺寸压缩</a></p>
<blockquote>
<p>全面碾压png, jpg, gif<br>
缺点：是并非所有浏览器都支持webp格式</p>
</blockquote>
<p>5.<a href="https://join-screenshots.zhanghai.me/">截图拼接工具</a></p>
<p>6.<a href="https://wordart.com/create">创建二维码文字云</a></p>
<p>7.<a href="https://qrbtf.com/">参数化二维码生成器</a></p>
<h3 id="2视频">2.视频</h3>
<p>1.<a href="https://www.urlgot.com/">全能视频在线下载工具</a></p>
<blockquote>
<p>或：mac软件 Downie</p>
</blockquote>
<p>2.<a href="https://www.kpkuang.com/">可直播院线电影的神奇网站</a></p>
<blockquote>
<p>少有的无需VIP, 播放流畅，片源齐全的影视网站<br>
缺点：大多数影片没有超清版</p>
</blockquote>
<p>3.<a href="https://www.mp4pa.com/">高清MP4下载</a></p>
<p>4.<a href="https://watermark.liumingye.cn/">抖音短视频无水印解析下载</a></p>
<h3 id="3歌曲">3.歌曲</h3>
<p>1.<a href="http://tool.liumingye.cn/music/">在线听QQ音乐，网易云音乐所有VIP歌曲</a>（推荐）</p>
<blockquote>
<p>支持下载封面和无损音乐<br>
默认第一个是QQ音乐，第二个是网易云音乐</p>
</blockquote>
<h2 id="6素材">6.素材</h2>
<p>1.<a href="https://pictogram2.com/">专业火柴人素材站</a></p>
<blockquote>
<p>丰富的火柴人素材，提高PPT的设计档次</p>
</blockquote>
<p>2.<a href="https://uigradients.com/">为PPT找到优质而渐变色背景</a></p>
<p>3.<a href="https://hitokoto.cn/">总有那么几个句子能穿透你的心</a></p>
<blockquote>
<p>网站提供了第三方接口,任何人可以通过接口https://v1.hitokoto.cn/获取一句话</p>
</blockquote>
<h2 id="7免费软件">7.免费软件</h2>
<p>1.<a href="https://xclient.info">xclient</a></p>
<p>2.<a href="https://macwk.com/">macwk</a></p>
<p>3.<a href="https://www.xxmac.com/">xxmac</a></p>
<p>4.<a href="www.zhinin.com">知您</a></p>
<p>5.<a href="https://igetintopc.com/">更新极快的绿色软件站</a></p>
<p>6.<a href="https://www.jokerps.com/">鹏少</a></p>
<p>7.<a href="https://www.naodai.org/">脑袋瓜子</a></p>
<p>8.<a href="http://free.apprcn.com/">白送软件</a></p>
<blockquote>
<p>每天推送最新的软件限时免费信息</p>
</blockquote>
<p>9.<a href="https://node4.mkdmirror.workers.dev/0:/">反马克丁，绿色免费软甲</a></p>
<blockquote>
<p>马克丁：盗版软件起家，用盗版软件作为谈判筹码，获得正版软件厂商授权，然后开始大肆投诉授权软件的其它盗版资源站<br>
把获得授权的正版软件破解，加入自己的签名，并创造出自家的激活码，并大幅提升软件价格</p>
</blockquote>
<h2 id="99其它">99.其它</h2>
<p>1.<a href="https://www.itjuzi.com/deathCompany">死亡公司公墓</a></p>
<blockquote>
<p>新经济死亡公司数据库</p>
</blockquote>
<p>2.<a href="https://www.pixiv.net/ranking.php?mode=male">Pixiv福利插画!year!</a></p>
<blockquote>
<p>账号：google账号：china3q8@gmail.com<br>
密码：tshi522581</p>
</blockquote>
<p>3.<a href="https://fuun.fun/">奇妙网站</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图床]]></title>
        <id>https://wo-wo.github.io/post/tu-chuang/</id>
        <link href="https://wo-wo.github.io/post/tu-chuang/">
        </link>
        <updated>2021-10-19T14:23:10.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1客户端picgo">1.客户端PicGo</h3>
<p><a href="https://github.com/Molunerfinn/PicGo/">github-PicGo</a></p>
<blockquote>
<p>直接安装 dmg 客户端</p>
</blockquote>
<h4 id="1特性">1.特性</h4>
<ul>
<li>
<p>免费、开源图床工具：</p>
</li>
<li>
<p>支持Windows、MacOS 和 Linux，</p>
</li>
<li>
<p>软件目前覆盖的图床有8个平台：</p>
<blockquote>
<p>SM.MS图床、腾讯云COS、微博图床、GitHub(gitee)图床、七牛图床、Imgur图床、阿里云OSS、又拍云图床</p>
</blockquote>
</li>
<li>
<p>提供五种链接格式:markdown、HTML、URL、UBB、Custom</p>
</li>
<li>
<p>支持拖动上传图片，完成后弹窗提示</p>
</li>
<li>
<p>相册可以批量复制和删除</p>
</li>
<li>
<p>删除列表并未删除图床内的图</p>
</li>
<li>
<p>官方提供了很多扩展插件</p>
</li>
</ul>
<h3 id="2图床选择-gitee">2.图床选择 gitee</h3>
<p><a href="https://zhuanlan.zhihu.com/p/35270383">知乎-盘点国内免费好用的图床</a></p>
<p>1.gitee（推荐）</p>
<blockquote>
<p>免费、国内速度快</p>
</blockquote>
<p>2.github</p>
<blockquote>
<p>免费；但是速度有时没法保证</p>
</blockquote>
<p>3.七牛云</p>
<blockquote>
<p>注册认证后有10G永久免费空间，每月10G国内和10G国外流量，速度相当快，七牛云是国内专业CDN服务商，插件支持比较多，有免费ssl证书;<br>
https流量收费；<br>
七牛云30天后会回收测试域名，因此你必须要绑定自己的已备案的域名</p>
</blockquote>
<p>4.又拍云</p>
<blockquote>
<p>注册认证后有10G永久免费空间，每月15G的HTTP和HTTPS流量，提供两款可以免费续期的SSL证书;<br>
用户需要加入又拍云联盟;<br>
需要绑定自己的已备案域名，又拍云认证比较麻烦，建议使用七牛云</p>
</blockquote>
<p>5.SM.MS</p>
<blockquote>
<p>永久存储免注册，支持https，可以删除上传的图片，提供多种图片链接格式，免费用户无法使用香港节点因此速度比较慢<br>
图片上传限制：每个图片最大5M，每次最多上传10张</p>
</blockquote>
<p>6.腾讯云</p>
<blockquote>
<p>仅可以使用六个月的免费存储容量、免费请求和免费流量，不推荐使用<br>
限制：时间、流量、空间大小均有限制</p>
</blockquote>
<h3 id="3picgo上gitee图床配置">3.PicGo上gitee图床配置</h3>
<blockquote>
<p>默认不支持 gitee，需要安装插件；<br>
gitee-uploader 与 github-plus都可以；</p>
</blockquote>
<h4 id="1安装插件-gitee-uploader">1.安装插件 gitee-uploader</h4>
<blockquote>
<p>打开PicGo配置，插件设置，搜索插件，安装。<br>
安装成功后，会在图床设置下出现 gitee</p>
</blockquote>
<h4 id="2gitee配置">2.gitee配置</h4>
<p>1.gitee上创建一个<code>共有仓库</code></p>
<blockquote>
<p>这个仓库最好是public的，因为private的仓库，图片链接会带token，这个token又存在过期的问题。例：https://gitee.com/shizq/imgs<br>
因是公用仓库，所以最后不存放敏感信息图片。</p>
</blockquote>
<p>2.gitee上生成一个<code>私人令牌</code></p>
<blockquote>
<p>gitee，设置-&gt;安全设置-&gt;私人令牌-&gt;生成新令牌。获取到token，先保存下来</p>
</blockquote>
<p>3.配置PicGo的gitee图床</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210110215009.png" alt="" loading="lazy"></figure>
<blockquote>
<p>repo：gitee上仓库名<br>
branch：gitee仓库对应的分支，一般master<br>
token：第2步生成的token<br>
path：仓库下的目录，非必填<br>
customPath：自定义图片名。default：原图片名；年月：以年月崇命名图片文件</p>
</blockquote>
<p>例：</p>
<table>
<thead>
<tr>
<th>repo</th>
<th>shizq/imgs</th>
</tr>
</thead>
<tbody>
<tr>
<td>branch</td>
<td>master</td>
</tr>
<tr>
<td>token</td>
<td>***</td>
</tr>
<tr>
<td>path</td>
<td>PicGo/</td>
</tr>
<tr>
<td>customPath</td>
<td>年月</td>
</tr>
<tr>
<td>customUrl</td>
<td>空</td>
</tr>
</tbody>
</table>
<p>4.上传完后图片地址</p>
<blockquote>
<p>剪切板上，直接使用；<br>
或者点击相册，复制地址；</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[chrome：极好用插件]]></title>
        <id>https://wo-wo.github.io/post/chromeji-hao-yong-cha-jian/</id>
        <link href="https://wo-wo.github.io/post/chromeji-hao-yong-cha-jian/">
        </link>
        <updated>2021-10-19T14:22:00.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1下载安装">1.下载安装</h3>
<h4 id="1下载">1.下载</h4>
<h5 id="1极简插件">1.极简插件</h5>
<p>1.<a href="https://chrome.zzzmh.cn/index#index">极简插件</a>（国内、免费）</p>
<h5 id="2github下载">2.github下载</h5>
<p>1.安装：</p>
<blockquote>
<p>1.解压<br>
2.浏览器-&gt;加载已解压的拓展文件-&gt;选中解压文件下的 chrome-&gt;release 文件夹</p>
</blockquote>
<p>2.注意：</p>
<ul>
<li>1.如果出现 js/css 加载错误</li>
</ul>
<blockquote>
<p>目录文件没选择对</p>
</blockquote>
<ul>
<li>2.加载拓展程序后，解压文件地址不能再变动，否则插件失效</li>
</ul>
<h5 id="3chrome商城">3.chrome商城</h5>
<p>1.科学上网</p>
<ul>
<li>
<p>1.直接安装（没文件）</p>
</li>
<li>
<p>2.有文件</p>
<blockquote>
<p>1.https://www.chromefor.com/，搜索对应的插件；（只能搜索插件，不用搜索app应用）<br>
2.查看页面元素，找“谷歌商城下载地址”按钮，拿到对应的extension id；<br>
3.再打开 https://chrome-extension-downloader.com/，输入对应的extension id，下载。</p>
</blockquote>
</li>
</ul>
<h4 id="2问题">2.问题</h4>
<h5 id="1插件安装失败">1.插件安装失败：</h5>
<p>错误1：CRX_HEADER_INVALID<br>
错误2：无法从该网站添加应用、扩展程序和用户脚本</p>
<blockquote>
<p>1.原因：Chrome更新时，改变了头部信息打包方式！<br>
2.结果：导致老版本Chrome打包的crx插件，无法直接安装在新版本Chrome中</p>
</blockquote>
<p>解法1：拖动 xxx.crx 到拓展程序</p>
<blockquote>
<p>1.新版 chrome 打包的 crx 拓展可以</p>
</blockquote>
<p>解法2：暴力安装：xxx.crx 的扩展名改为 xxx.zip</p>
<blockquote>
<p>1.改完拓展名后，拖动安装<br>
2.注：该方法大部分情况下可以一次成功，个别时候会收到浏览器安全提醒，忽略即可</p>
</blockquote>
<p>解法3：商店直装（科学上网）</p>
<h3 id="2推荐插件">2.推荐插件</h3>
<h4 id="1油猴脚本tampermonkey">1.油猴脚本：Tampermonkey</h4>
<blockquote>
<p>1.免费的浏览器扩展和最为流行的用户脚本管理器。支持各个主流浏览器<br>
2.通俗的讲：安装完后，浏览器自动在指定 url 内，执行指定的 js 脚本（例：百度网盘直链下载助手）</p>
</blockquote>
<p>1.安装插件<br>
<a href="https://chrome.zzzmh.cn/info?token=dhdgffkkebhmkfjojejmpbldmpobfkfo">油猴脚本</a></p>
<p>2.安装脚本<br>
<a href="https://greasyfork.org/zh-CN/scripts">推荐地址</a><br>
<a href="https://www.tampermonkey.net/scripts.php">官网地址</a> (慢)</p>
<p>3.推荐脚本</p>
<ul>
<li>1.网盘助手</li>
</ul>
<blockquote>
<p>1.使用：浏览器插件(NeatDownloadManager)高速下载<br>
2.步骤：勾选文件 -&gt; 生成链接 -&gt; 右键 -&gt; NeatDownloadManager，即可开始高速下载</p>
</blockquote>
<ul>
<li>2.搜索引擎去广告</li>
</ul>
<blockquote>
<p>AC-baidu:重定向优化百度搜狗谷歌必应搜索_favicon_双列</p>
</blockquote>
<ul>
<li>3.全网VIP视频免费破解</li>
</ul>
<blockquote>
<p>懒人专用，全网VIP视频免费破解去广告、全网音乐直接下载、百度网盘直接下载、知乎视频下载等多合一版。长期更新，放心使用</p>
</blockquote>
<h4 id="2vimium装逼神器">2.vimium：装逼神器</h4>
<blockquote>
<p>拓展id：dbepggeogbaibhgnhhndojpepiihcmeb</p>
</blockquote>
<p>1.快捷键</p>
<pre><code># 快捷键
# 1.当前页
?       显示help
j,&lt;c-e&gt; 向下滚动(&lt;c-e&gt;即ctrl+e)
k,&lt;c-y&gt; 向上滚动
h       向左滚动
zH      滚动到最左边
l       向右滚动
zL      滚动到最后边
d       向下滚动半页
u       向上滚动半页
r       刷新
gg      滚动到顶部
G       滚动到底部
f       显示所有的链接字母（按下小写的字母在当前页打开；大写在新页打开）
F,&lt;a-f&gt; 显示所有的链接字母(&lt;a-f&gt;即alt+f)（按下小写或大写的字母都在新页打开）
yy      复制当前页地址
yf      显示所有的链接字母，按下字母，复制对应的链接
gs      显示页面源代码
gf      循环前往html的下一个frame
gF      聚焦到顶/主部的frame
i       进入插入模式，所有按键命令无效，直至esc退出

# 2.打开新页面
o   搜索网址，书签或历史记录，在当前页打开（每个地址前都要出处，esc退出）
O   搜索网址，书签或历史记录，在新页打开
b   搜索书签，在当前页打开
B   搜索书签，在新页打开
T   搜索所有打开的tab页面

# 3.查找
/   进入查找模式，关键字查找，esc退出
n   切换到下一个匹配
N   切换到上一个匹配

# 4.前进后退
H   后退
L   前进

# 5.切换tab
J,gT   切换到左边的tab
K,gt   切换到右边的tab
g0     切换到第一个tab
g$     切换到最后一个tab
^      切换到刚才的tab
t      新建一个页面
nt     新建n个页面
yt     复制当前页（新建一个页面，并打开刚才页面）
x      关闭当前页
X      恢复刚才关闭的页面，并聚焦到浏览历史锚点，可以连续恢复多个
&lt;a-p&gt;  钉住/不钉住当前页(&lt;a-p&gt;即alt+p)（将当前页移到第一个tab，并钉住，不可移动；再次按，释放）

# 6.标记
ma     当页标记，某个位置（m+任意一个小写字母）
`a     跳转到当页标记的位置（a是ma标记时的字母）
``     跳转到当页标记的位置
mA     全局标记，某个页面的位置（m+任意一个大写字母）
`A     从任意tab中跳转到全局标记的页面位置（A是mA标记时的字母）

# 7.进阶命令
gi     聚焦到当前页的第一个输入框
gu     跳转到当前网址的上一级网址
gU     跳转到当前网址的跟网址
ge     编辑当前网址，并在当前页打开
gE     编辑当前网址，并在新页打开
</code></pre>
<h4 id="3fehelperweb前端助手利器">3.FeHelper：WEB前端助手（利器）</h4>
<blockquote>
<p>拓展id：pkgccpejnmalmdinmhkkfafefagiiiad</p>
</blockquote>
<p>功能：</p>
<ul>
<li>1.字符串加解密：Unicode、URL、base64、md5</li>
<li>2.json串格式化：粘贴文本，手动格式化；页面自动检测并格式化（取代JSON Editor插件，拓展id：lhkmoheomjbkfloacpgllgjcamhihfaj）</li>
<li>3.代码美化工具：js、css、html、xml、sql；页面自动检测并美化处理</li>
<li>4.代码压缩工具：js、css、html</li>
<li>5.二维码生成器：支持当前页面、图片、链接、选中的文字生成QrCode（取代Simple QR插件，拓展id：bfpobnbhgondhofhkolbelkijdmgfjfm）</li>
<li>6.网页滚动截屏：将当前整个网页滚动截屏转换为图片</li>
<li>7.页面取色工具：滑动鼠标随意取色</li>
<li>8.正则表达式</li>
<li>9.时间戳转换工具</li>
<li>10.图片转Base64：任意图片转DataURI格式，支持拖拽、复制粘贴自动转化</li>
<li>11.Markdown转换：html与markdown互相转换</li>
<li>12.编码规范检测：js、css、html规范检测</li>
<li>13.页面性能检测：页面响应时间、Header监测</li>
<li>14.Ajax调试功能：需在控制台中使用</li>
</ul>
<h4 id="4neatdownloadmanager多线程下载插件">4.NeatDownloadManager：多线程下载插件</h4>
<blockquote>
<p>极大提升下载速度；<br>
还能配合油猴脚本中的，网盘工具，快速下载，速度能&gt;10M/s</p>
</blockquote>
<h4 id="5evernote映像笔记">5.evernote：映像笔记</h4>
<p>浏览器打开笔记<br>
1.支持各个平台，Chrome插件，完爆有道云<br>
2.对比：Evernote比较好用；如果你的笔记中存在大量高清图片，Evernote收费，有道云免费</p>
<h4 id="6onetab所有tab保存">6.OneTab：所有tab保存</h4>
<blockquote>
<p>拓展id：chphlpgkkbolifaimnlloiipkdnihall<br>
释放内存，关闭所有tab，然后保存到一个tab中</p>
</blockquote>
<h4 id="7neater-bookmarks书签管理插件">7.Neater Bookmarks：书签管理插件</h4>
<blockquote>
<p>拓展id：ofgjggbjanlhbgaemjbkiegeebmccifi<br>
可以用 vimium 的 B 搜索书签功能替代</p>
</blockquote>
<h4 id="8octotreegithub树形结构展示">8.Octotree：github树形结构展示</h4>
<blockquote>
<p>拓展id：bkhaagjahfmjljalopjnoealnfndnagc</p>
</blockquote>
<h4 id="9xpath-helper">9.XPath Helper</h4>
<blockquote>
<p>拓展id：hgimnogjllphhhkhlmebbmlgjoejdpjl</p>
</blockquote>
<p><a href="https://www.w3school.com.cn/xpath/xpath_syntax.asp">xpath语法</a>：</p>
<blockquote>
<p>1.快捷键：Ctrl+Shift+X（Windows），Command+Shift+X（OS X）</p>
</blockquote>
<pre><code># 例：
//div[contains(@class, &quot;news-list-detail&quot;)]/p[contains(@class, &quot;news-list-detail-info&quot;)]/a[last()]/text()
//div[contains(@class, &quot;news-list-detail&quot;)]/a/@href
</code></pre>
<h4 id="10advertising-terminator广告终结者">10.Advertising-Terminator：广告终结者</h4>
<blockquote>
<p>拓展id：fpdnjdlbdmifoocedhkighhlbchbiik<br>
清除网页上的所有广告：浮动广告，购物广告，恶意弹窗，跟踪代码，视频广告</p>
</blockquote>
<h4 id="11adfreeplayeronline视频广告屏蔽扩展">11.ADfree.Player.Online：视频广告屏蔽扩展</h4>
<p>1.一款屏蔽国内主要视频网站部分视频广告的扩展<br>
2.扩展目前支持：优酷、土豆、搜狐、爱奇艺、乐视。（不支持腾讯）<br>
3.会与其他需要代理权限的扩展冲突，例Proxy SwitchyOmega。</p>
<p><a href="https://bbs.kafan.cn/thread-1777920-1-1.html">解决冲突</a></p>
<h4 id="12momentum替换默认tab页">12.Momentum：替换默认tab页</h4>
<blockquote>
<p>拓展id：laookkfknpbbblfpciffpaejjkokdgca<br>
替换默认tab页，每天一副摄影图片；看时间和温度，可以填写提醒事项</p>
</blockquote>
<h4 id="13掘金">13.掘金</h4>
<blockquote>
<p>拓展id：lecdifefmmfjnjjinhaennhdlmcaeeeb<br>
1.在新标签页中，推送国内外优质互联网站点，行业相关文章。<br>
2.默认开启，可以关闭</p>
</blockquote>
<h4 id="14aria2gui-baiduexporter百度网盘离线脚本">14.Aria2GUI、baiduExporter：百度网盘离线脚本</h4>
<blockquote>
<p>拓展id：kidicenkmkhnjipapnkomalnjobgefoi<br>
建议使用油猴脚本替代</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/b58fff3fb946">使用参考</a></p>
<blockquote>
<p>1.插件(baiduExporter):安装之后，在网页版百度网盘上多个『导出下载』按钮，点击，勾选『aria2 rpc』后瞬间将软件导入到Aria2GUI<br>
2.Aria2离线下载软件。无限速<br>
3.注意：<br>
使用离线脚本时，Aria2GUI 需要先打开；<br>
部分软件下载不成功（企业版）HTTP response header was bad or unexpected。</p>
</blockquote>
<h5 id="1安装与使用">1.安装与使用</h5>
<p><a href="https://www.jianshu.com/p/b58fff3fb946">参考</a><br>
1.步骤<br>
1.<a href="https://github.com/yangshun1029/aria2gui/releases">下载客户端 Aria2GUI</a></p>
<p>2.<a href="https://github.com/acgotaku/BaiduExporter">下载chrome插件 BaiduExporter</a></p>
<p>3.修改配置 aria2.conf</p>
<blockquote>
<p>修改默认配置<br>
/Volumes/hd2/1.mac/6.chrome/BaiduExporter-master/aria2c/aria2.conf<br>
将其中 dir= 注释掉，变成默认下载路径 /Users/shiq/Downloads</p>
</blockquote>
<p>4.安装chrome插件（.zip格式）</p>
<blockquote>
<p>解压，浏览器-&gt;加载已解压的拓展文件-&gt;选中解压文件下的 chrome-&gt;release<br>
注：如果出现 js/css 加载错误，是目录文件没选择对；<br>
加载拓展程序后，解压文件地址不能再变动，否则插件失效</p>
</blockquote>
<p>5.运行</p>
<blockquote>
<p>1.打开 Aria2GUI 客户端，<br>
2.在浏览器上打开百度网盘，当出现导出下载，插件安装完成。<br>
3.勾选下载的文件，击ARIA2 RPC下载任务就会被客户端执行。</p>
</blockquote>
<h5 id="2错误">2.错误</h5>
<p>1.ria2GUI 客户端一直报错：Internal server error<br>
2.网页点击 导出下载 -&gt; RIA2 RPC。报错：下载失败 是不是没有开启aria2</p>
<blockquote>
<p>1.原因：Aria2GUI 客户端未放入应用程序中，没网络权限（问题1）；导致aria2没启动（问题2）<br>
2.解决方案：将 Aria2GUI 客户端放入应用程序：将解压后的app，放在 ~/Applications 下，完整路径：/Users/shiq/Applications<br>
3.注：一定要放在当前用户的应用下 ~/Applications ，不能放在跟目录的应用下</p>
</blockquote>
<h4 id="15axurerp加载静态html">15.AxureRP：加载静态html</h4>
<p>拓展id：dogkpdfcklifaemcdfbildhcofnopogp</p>
<h4 id="16similarweb查看网站各种流量数据">16.SimilarWeb：查看网站各种流量数据</h4>
<blockquote>
<p>拓展id：hoklmmgfnpapgjgcpechhaamimifchmp</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/a289fc9d0fe4">分析</a><br>
<a href="https://study.163.com/course/introduction.htm?courseId=1025008#/courseDetail?tab=1">免费实操视频</a></p>
<blockquote>
<p>1.自己网站的数据：Google Analytics<br>
2.竞对：SimilarWeb<br>
3.免费版；收费版pro：12000$/年（大概）</p>
</blockquote>
<h4 id="17谷歌访问助手">17.谷歌访问助手</h4>
<blockquote>
<p>免费，但有广告。强制设置主页为：https://2018.hao245.com<br>
才能永久激活</p>
</blockquote>
<h4 id="18google学术助手">18.Google学术助手</h4>
<blockquote>
<p>1.无需任何操作，即可免费访问谷歌、gmail、chrome商店，缺点是会有一定几率触发打开2345广告页面。<br>
2.注：即使google代理设置失败，仍然可以使用。点击图标，勾选对应的搜索引擎，选择可用的节点</p>
</blockquote>
<h4 id="19集装箱google-学术搜索-拒绝捆绑下载">19.集装箱：Google 学术搜索 + 拒绝捆绑下载</h4>
<h4 id="20-eolinker-api-studio-pluginseolinker的接口测试工具插件">20 EOLINKER-API-Studio-Plugins：eolinker的接口测试工具插件</h4>
<blockquote>
<p>高于 5.0.3 版本的插件都不能使用（测试不会发送请求）</p>
</blockquote>
<h4 id="21vip视频解析vip视频解析_200_chrome">21.vip视频解析:vip视频解析_2.0.0_chrome</h4>
<h4 id="22vysor解放双手的-android-测试工具">22.Vysor：解放双手的 Android 测试工具</h4>
<blockquote>
<p>拓展id：kdphpklacmlhmooodiekhpbepcdlaghl</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/66608ffebc31">破解版</a></p>
<blockquote>
<p>免root实现电脑控制手机的chrome插件</p>
</blockquote>
<h4 id="23user-agent-switcher-for-google-chrome模拟不同的浏览器">23.User-Agent Switcher for Google Chrome：模拟不同的浏览器</h4>
<blockquote>
<p>选goole.com提供；<br>
拓展id：djflhoibgkdhkhhcedjiklpkjnoahfmg</p>
</blockquote>
<p><strong>注意：相似的插件有3个，其中一个是木马</strong></p>
<blockquote>
<p>1.User-Agent Switcher 由www.toolshack.com提供。<br>
拓展 id:lkmofgnohbedopheiphabfhfjgkhfcgf<br>
2.User-Agent Switcher for Chrome 由goole.com提供;<br>
拓展id:djflhoibgkdhkhhcedjiklpkjnoahfmg（推荐）<br>
3.User-Agent Switcher for Google Chrome 由useragentswitcher.org提供;<br>
拓展 id：ffhkkpnppgnfaobgihpdblnhmmbodake（木马）</p>
</blockquote>
<p><a href="http://www.freebuf.com/news/147188.html">新闻</a></p>
<h4 id="24page-ruler网页标尺">24.Page Ruler：网页标尺</h4>
<blockquote>
<p>拓展id：jlpkojjdgbllmedoapgfodplfhcbnbpn</p>
</blockquote>
<h4 id="25react-developer-toolsreact调试工具">25.React Developer Tools：React调试工具</h4>
<blockquote>
<p>拓展id：fmkadmapgofadopljbjfkapdkoienihi</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/ae482813b791">react简介</a></p>
<blockquote>
<p>eact：是一个新的js库，不是mvc框架，是构建易于可重复调用的web组件；<br>
单向数据流；<br>
virtual DOM虚拟DOM通过diff算法最小步骤更新到真实DOM</p>
</blockquote>
<h4 id="26proxy-switchyomega代理扩展程序">26.Proxy SwitchyOmega：代理扩展程序</h4>
<blockquote>
<p>拓展id：padekgcemlokbadohgkifijomclgjgif<br>
<a href="https://www.cnplugins.com/devtool/proxy-switchyomega/detail.html">参考</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-20.性能调优：分析工具]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-20xing-neng-diao-you-fen-xi-gong-ju/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-20xing-neng-diao-you-fen-xi-gong-ju/">
        </link>
        <updated>2021-10-12T03:19:35.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="pprof">pprof</h2>
<p>软件开发过程中，项目上线并不是终点。上线后，还要对程序的取样分析运行情况，并重构现有的功能，让程序执行更高效更稳写。 golang的工具包内自带pprof功能，使找出程序中占内存和CPU较多的部分功能方便了不少。加上uber的火焰图，可视化显示，让我们在分析程序时更简单明了。</p>
<h3 id="准备工作">准备工作</h3>
<ul>
<li>安装graphviz
<ul>
<li>brew install graphviz</li>
</ul>
</li>
<li>将 $GOPATH/bin 加⼊ $PATH
<ul>
<li>Mac OS: 在 .bash_profile 中修改路径</li>
</ul>
</li>
<li>安装 go-torch（不使用可以不装）
<ul>
<li>go get github.com/uber/go-torch</li>
<li>下载并复制 flamegraph.pl （https://github.com/brendangregg/FlameGraph）⾄ $GOPATH/bin 路径下</li>
<li>将 $GOPATH/bin 加⼊ $PATH</li>
</ul>
</li>
</ul>
<h3 id="pprof-2">pprof</h3>
<ul>
<li>
<p>采样方式：</p>
<ul>
<li>runtime/pprof：工具型应用，采集程序（非 Server）的运行数据进行分析</li>
<li>net/http/pprof：服务型应用，采集 HTTP Server 的运行时数据进行分析</li>
</ul>
</li>
<li>
<p>支持模式：</p>
<ul>
<li>Report generation：报告生成</li>
<li>Interactive terminal use：交互式终端使用</li>
<li>Web interface：Web 界面</li>
</ul>
</li>
<li>
<p>分析类型</p>
<ul>
<li>
<p>CPU Profiling：</p>
<blockquote>
<p>CPU 分析是最常见的性能分析类型。</p>
<p>按照一定的频率（默认10ms一次）采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置。</p>
</blockquote>
</li>
<li>
<p>Memory Profiling：</p>
<blockquote>
<p>内存性能分析记录堆内存分配时的堆栈信息，忽略栈内存分配信息。</p>
<p>内存性能分析启用时，默认每1000次采样1次，这个比例是可以调整的。因为内存性能分析是基于采样的，因此基于内存分析数据来判断程序所有的内存使用情况是很困难的。</p>
</blockquote>
</li>
<li>
<p>Block Profiling：</p>
<blockquote>
<p>阻塞性能分析是 Go 特有的。</p>
<p>阻塞性能分析用来记录一个协程等待一个共享资源花费的时间。在判断程序的并发瓶颈时会很有用。阻塞的场景包括：</p>
<ul>
<li>在没有缓冲区的信道上发送或接收数据。</li>
<li>从空的信道上接收数据，或发送数据到满的信道上。</li>
<li>尝试获得一个已经被其他协程锁住的排它锁。</li>
</ul>
<p>一般情况下，当所有的 CPU 和内存瓶颈解决后，才会考虑这一类分析。</p>
<p>默认不开启，需要调用 <code>runtime.SetBlockProfileRate</code> 进行设置。</p>
</blockquote>
</li>
<li>
<p>Mutex Profiling：</p>
<blockquote>
<p>锁性能分析与阻塞分析类似，但专注于因为锁竞争导致的等待或延时。</p>
<p>默认不开启，需要调用 <code>runtime.SetMutexProfileFraction</code> 进行设置。</p>
</blockquote>
</li>
<li>
<p>Goroutine Profiling：</p>
<blockquote>
<p>Goroutine 分析，可以对当前应用程序正在运行的 Goroutine 进行堆栈跟踪和分析。这项功能在实际排查中会经常用到，因为很多问题出现时的表象就是 Goroutine 暴增，而这时候我们要做的事情之一就是查看应用程序中的 Goroutine 正在做什么事情，因为什么阻塞了，然后再进行下一步。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="采样">采样</h3>
<h4 id="runtimepprof工具型应用">runtime/pprof：工具型应用</h4>
<ul>
<li>通过嵌入代码，手动调用 runtime/pprof 的 API</li>
<li>灵活性⾼，适⽤于特定代码段的分析</li>
<li>API 相关⽂档 https://studygolang.com/static/pkgdoc/pkg/runtime_pprof.htm</li>
<li>go tool pprof [binary] [binary.prof]</li>
</ul>
<h6 id="开启方式">开启方式</h6>
<pre><code>import &quot;runtime/pprof&quot;
//cpu
f, err := os.Create(&quot;cpu.prof&quot;) //创建一个文件句柄
pprof.StartCPUProfile(f) //开启
pprof.StopCPUProfile() //关闭
//内存
pprof.WriteHeapProfile(f1)
</code></pre>
<h4 id="nethttppprof服务型应用">net/http/pprof：服务型应用</h4>
<ul>
<li>简单，适合于持续性运⾏的应⽤</li>
<li>在应⽤程序中导⼊ import _ &quot;net/http/pprof&quot;，并启动 http server 即可</li>
<li>http://<host>:<port>/debug/pprof/</li>
<li>go tool pprof http://<host>:<port>/debug/pprof/profile?seconds=10 （默认值为30秒）</li>
<li>go-torch -seconds 10 http://<host>:<port>/debug/pprof/profile</li>
</ul>
<h6 id="开启方式-2">开启方式</h6>
<pre><code>//http包使用方式
//如果使用了默认的http.DefaultServeMux（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)），只需要import _ &quot;net/http/pprof&quot;即可
//如果使用的是自定义的 Mux，则需要手动注册一些路由规则：
r.HandleFunc(&quot;/debug/pprof/&quot;, pprof.Index)
r.HandleFunc(&quot;/debug/pprof/cmdline&quot;, pprof.Cmdline)
r.HandleFunc(&quot;/debug/pprof/profile&quot;, pprof.Profile)
r.HandleFunc(&quot;/debug/pprof/symbol&quot;, pprof.Symbol)
r.HandleFunc(&quot;/debug/pprof/trace&quot;, pprof.Trace)

//gin框架使用方式
//1、github.com/gin-contrib/pprof
//2、github.com/DeanThompson/ginpprof
import &quot;github.com/gin-contrib/pprof&quot;
pprof.Register(r)
</code></pre>
<h6 id="文件地址">文件地址</h6>
<pre><code># http://&lt;host&gt;:&lt;port&gt;/debug/pprof/
allocs：查看过去所有内存分配的样本，访问路径为 $HOST/debug/pprof/allocs。
block：查看导致阻塞同步的堆栈跟踪，访问路径为 $HOST/debug/pprof/block。
cmdline： 当前程序的命令行的完整调用路径。
goroutine：查看当前所有运行的 goroutines 堆栈跟踪，访问路径为 $HOST/debug/pprof/goroutine。
heap：查看活动对象的内存分配情况，访问路径为 $HOST/debug/pprof/heap。
mutex：查看导致互斥锁的竞争持有者的堆栈跟踪，访问路径为 $HOST/debug/pprof/mutex。
profile： 默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件，访问路径为 $HOST/debug/pprof/profile。
threadcreate：查看创建新 OS 线程的堆栈跟踪，访问路径为 $HOST/debug/pprof/threadcreate。

1、web界面点击链接默认带debug=1，若没有debug参数，那么将会直接下载对应的 profile 文件。
2、在部署环境中，为了网络安全，通常不会直接对外网暴露 pprof 的相关端口，因此会通过 curl、wget 等方式进行 profile 文件的间接拉取。
3、debug 的访问方式是具有时效性的，在实际场景中，我们常常需要及时将当前状态下的 profile 文件给存储下来，便于二次分析。
</code></pre>
<h2 id="交互式终端go-tool-pprof">交互式终端（go tool pprof）</h2>
<pre><code>#go tool pprof
go tool pprof + prof文件进入交互式终端，有以下几个命令
top  默认查看程序中占用cpu前10位的函数，后面可跟数字，默认以flat排列，可使用-cum以cum排列
list +函数名命令查看具体的函数分析
traces 查看调用链路
pdf  可以生成可视化的pdf文件。
svg  生成svg
web  直接生成关系调用图（方块越大表示消耗越大）：
     注意：如果没有安装graphviz，会出现Could not execute dot；may need to install graphviz

#top详解
(pprof) top
Showing nodes accounting for 71.27s, 75.62% of 94.25s total
Dropped 211 nodes (cum &lt;= 0.47s)
Showing top 10 nodes out of 97
      flat  flat%   sum%        cum   cum%
    23.32s 24.74% 24.74%     23.32s 24.74%  runtime.pthread_cond_wait
    10.09s 10.71% 35.45%     10.09s 10.71%  runtime.pthread_kill
    10.08s 10.69% 46.14%     10.08s 10.69%  runtime.kevent
     7.19s  7.63% 53.77%     19.04s 20.20%  main.GetFibonacciServe
     5.10s  5.41% 59.18%      5.10s  5.41%  runtime.procyield
     4.34s  4.60% 63.79%      8.12s  8.62%  runtime.scanobject
     4.17s  4.42% 68.21%      4.17s  4.42%  runtime.pthread_cond_signal
     2.72s  2.89% 71.10%      2.82s  2.99%  runtime.nanotime1
     2.32s  2.46% 73.56%      2.33s  2.47%  runtime.usleep
     1.94s  2.06% 75.62%      1.94s  2.06%  runtime.memclrNoHeapPointers
     
flat：当前函数占用CPU的耗时
flat%：当前函数占用CPU的耗时百分比
sum%：函数占用CPU的累积耗时百分比
cum：当前函数+调用当前函数的占用CPU总耗时
cum%：当前函数+调用当前函数的占用CPU总耗时百分比

【flat和cum的区别】假设函数b由三部分组成：调用函数c、自己直接处理一些事情、调用函数d，其中调用函数c耗时1秒，自己直接处理事情耗时3秒，调用函数d耗时2秒，那么函数b的flat耗时就是3秒，cum耗时就是6秒。
【flat%、cum%、sum%】flat%和cum%指的就是flat耗时和cum耗时占总耗时（也就是94.25秒）的百分比，而最后一个sum%指的就是每一行的flat%与上面所有行的flat%总和，代表从上到下的累计值，比如第二行的75.04%就等于第一行flat%的66.67%+本行flat%的8.37%，下面的以此类推
</code></pre>
<h4 id="cpu-profiling">CPU Profiling</h4>
<pre><code>go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30
// 执行该命令后，需等待 30 秒（可调整 seconds 的值），pprof 会进行 CPU Profiling，结束后将默认进入 pprof 的命令行交互式模式，可以对分析的结果进行查看或导出。另外如果你所启动的 HTTP Server 是 TLS 的方式，那么在调用 go tool pprof 时，需要将调用路径改为：
go tool pprof https+insecure://localhost:6060/debug/pprof/profile?seconds=30。
</code></pre>
<h4 id="heap-profiling">Heap Profiling</h4>
<pre><code>go tool pprof http://localhost:6060/debug/pprof/heap
// 执行该命令后，能够很快的拉取到其结果，因为它不需要像 CPU Profiling 做采样等待

// 可以选择传 type 它默认显示的是 inuse_space，实际上可以针对多种内存概况进行分析，常用的类别如下：
inuse_space：分析应用程序的常驻内存占用情况。
alloc_objects：分析应用程序的内存临时分配情况。
//另外还有 inuse_objects 和 alloc_space 类别，分别对应查看每个函数所分别的对象数量和查看分配的内存空间大小，具体可根据情况选用。
go tool pprof -alloc_objects http://localhost:6060/debug/pprof/heap
</code></pre>
<h4 id="goroutine-profiling">Goroutine Profiling</h4>
<pre><code>// 在查看 goroutine 时，我们可以使用 traces 命令，这个命令会打印出对应的所有调用栈，以及指标信息，可以让我们很便捷的查看到整个调用链路有什么，分别在哪里使用了多少个 goroutine，并且能够通过分析查看到谁才是真正的调用方
</code></pre>
<h4 id="mutex-profiling">Mutex Profiling</h4>
<pre><code>// 需要注意的是 runtime.SetMutexProfileFraction 语句，如果未来希望进行互斥锁的采集，那么需要通过调用该方法来设置采集频率，若不设置或没有设置大于 0 的数值，默认是不进行采集的。
func init() {
	runtime.SetMutexProfileFraction(1)
}
</code></pre>
<h4 id="block-profiling">Block Profiling</h4>
<pre><code>// 与 Mutex 的 runtime.SetMutexProfileFraction 相似，Block 也需要调用 runtime.SetBlockProfileRate() 进行采集量的设置，否则默认关闭，若设置的值小于等于 0 也会认为是关闭。
func init() {
	runtime.SetBlockProfileRate(1)
}
</code></pre>
<h2 id="web-界面">Web 界面</h2>
<p>方法一（推荐）：</p>
<pre><code># 该命令将在所指定的端口号运行一个 PProf 的分析用的站点。
go tool pprof -http=:6001 profile

# 包含内容：
# Top
# Graph
# Flame Graph （火焰图）
# Peek 相较于 Top 视图，增加了所属的上下文信息的展示，也就是函数的输出调用者/被调用者。
# Source 主要是增加了面向源代码的追踪和分析，可以看到其开销主要消耗在哪里。
# Disassemble
</code></pre>
<p>方法二：</p>
<pre><code># 在go tool pprof交互式终端中使用web命令
(pprof) web
</code></pre>
<h2 id="安全地使用nethttppprof">安全地使用net/http/pprof</h2>
<h1 id="benchmark">benchmark</h1>
<ul>
<li>benchmark和普通的单元测试一样，都位于 <code>_test.go</code> 文件中。</li>
<li>函数名以 <code>Benchmark</code> 开头，参数是 <code>b *testing.B</code>。和普通的单元测试用例很像，单元测试函数名以 <code>Test</code> 开头，参数是 <code>t *testing.T</code>。</li>
<li><code>go test</code> 命令默认不运行 benchmark 用例的，如果我们想运行 benchmark 用例，则需要加上 <code>-bench</code> 参数。例如：</li>
</ul>
<pre><code>go test -bench .
// 支持正则表达式，下面这个代表运行以Fib结尾的benchmark用例：
go test -bench='Fib$' .
// 默认使用全部cpu核数，可通过-cpu参数改变，-cpu支持传入一个列表作为参数，例如：
go test -bench='Fib$' -cpu=2,4 .
// 默认运行时间为1s，可通过-benchtime指定时间或者次数：
go test -bench='Fib$' -benchtime=5s .
go test -bench='Fib$' -benchtime=50x .
// 默认执行一轮，可通过-count指定轮数：
go test -bench='Fib$' -benchtime=5s -count=3 .
// 可通过-benchmem可查看内存分配量和分配次数：
go test -bench=. -benchmem
//常用方法：
b.StopTimer() //暂停计时
b.ResetTimer() //重置定时器
b.StartTimer() //开始计时
//下面输出的意思是：通过1s时间内运行该方法33次,每次需要30403687ns，进行内存分配40次，每次分配45188395B内存
BenchmarkGenerate-8         33  30403687 ns/op  45188395 B/op  40 allocs/op
</code></pre>
<h1 id="延伸阅读">延伸阅读</h1>
<p><a href="https://deepzz.com/post/the-command-flag-of-go-test.html">Go 测试，go test 工具的具体指令 flag</a></p>
<p><a href="https://golang2.eddycjy.com/posts/ch6/03-trace/">go tool trace</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-19.go web request]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-19go-web-request/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-19go-web-request/">
        </link>
        <updated>2021-10-12T03:18:20.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1资料">1.资料</h3>
<ul>
<li>《Go Web 编程》</li>
<li><a href="https://www.yuque.com/bobby-zpcyu/fgg66n/hi6mlb">慕课网-Go开发工程师-课程文档</a></li>
<li><a href="https://www.kancloud.cn/shuangdeyu/gin_book/949412">Gin 中文文档</a></li>
<li><a href="https://www.yuque.com/xinliangnote/go-gin-api/ngc3x5">go-gin-api 文档</a></li>
<li><a href="http://doc.go-admin.cn/zh/">GoAdmin文档</a></li>
</ul>
<h3 id="2nethttp包">2.net/http包</h3>
<blockquote>
<p>与 http 交互，都是基于基础包 net/http；<br>
例如：gin 等</p>
</blockquote>
<p>问题：</p>
<ul>
<li>1.Go Web 编程，看下来，整体感受如何？</li>
<li>2.go web https服务器，如何搭建？</li>
<li>3.多路复用器的意义是什么？</li>
<li>4.处理器函数的原理、意义是什么？</li>
</ul>
<p>核心：</p>
<ul>
<li>DefaultServeMux 单例</li>
<li>处理器函数（HandlerFunc）</li>
<li>ListenAndServer()</li>
</ul>
<h4 id="1构建-go-web-服务器">1.构建 go web 服务器</h4>
<h5 id="1最简单的服务器">1.最简单的服务器</h5>
<pre><code>import (
	&quot;net/http&quot;
)

func main()  {
	//启动一个http服务器，监听8080端口。默认端口可省
	//nil：使用默认多路复用器 DefaultServeMux
	//问题：参数是处理器，为什么默认使用多路复用器？
	http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>
<h5 id="2附加配置的服务器">2.附加配置的服务器</h5>
<p>1.Server结构体</p>
<pre><code>type Server struct {
	Addr           string
	Handler        Handler
	ReadTimeout    time.Duration
	WriteTimeout   time.Duration
	MaxHeaderBytes int
	# https
	TLSConfig      *tls.Config
	TLSNextProto   map[string]func(*Server, *tls.Conn, Handler)
	
	ConnState      func(net.Conn, ConnState)
	ErrorLog       *log.Logger
	...
}
</code></pre>
<p>2.增加一些配置</p>
<pre><code>func main()  {
	server := http.Server{
		Addr: &quot;127.0.0.1:8080&quot;,
		Handler: nil,
	}
	server.ListenAndServe()
}
</code></pre>
<h5 id="3https-的服务器">3.HTTPS 的服务器</h5>
<pre><code>func main()  {
	server := http.Server{
		Addr: &quot;127.0.0.1:8080&quot;,
		Handler: nil,
	}
	server.ListenAndServeTLS(&quot;cert.pem&quot;, &quot;key.pem&quot;)
}
</code></pre>
<h4 id="2处理请求">2.处理请求</h4>
<h5 id="1处理器-handler">1.处理器 Handler</h5>
<blockquote>
<p>一个处理器就是一个拥有 ServeHTTP 方法，且签名相同（即参数相同）的接口</p>
</blockquote>
<pre><code># 注意是 ServeHTTP，不是 ServerHTTP
ServeHTTP(http.ResponseWriter, *http.Request)
</code></pre>
<h5 id="2多路复用器-defaultservemux">2.多路复用器 DefaultServeMux</h5>
<ul>
<li>
<p>不仅是多路复用器，还是一个处理器</p>
<blockquote>
<p>DefaultServeMux 是 ServeMux结构 的一个实例，而后者拥有 ServerHTTP 方法；<br>
即：DefaultServeMux 即是 ServeMux结构 的实例，也是 Handler 结构 的实例；</p>
</blockquote>
</li>
<li>
<p>多路复用器作用</p>
</li>
</ul>
<blockquote>
<p>是一个特殊处理器，唯一作用：根据请求的 URL 将请求重定向到不同处理器</p>
</blockquote>
<h5 id="3自定义处理器">3.自定义处理器</h5>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type MyHandler struct {}

func (h *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello world!&quot;)
}

func main()  {
	handler:= MyHandler{}
	server := http.Server{
		Addr: &quot;127.0.0.1:8080&quot;,
		Handler: &amp;handler,
	}
	//http://localhost:10000/
	//http://localhost:10000/aa/bb
	server.ListenAndServe()
}
</code></pre>
<p>浏览器访问 http://localhost:8080/，就可看到 Hello world 响应</p>
<p>4.问题：如果此时浏览器输入 http://localhost:8080/anything/all，结果是什么？</p>
<p>原因：使用自定义处理器，代替了默认 多路复用器；<br>
多路复用器作用：根据请求的 URL 将请求重定向到不同处理器；<br>
所以：直接使用自定义处理器处理所有请求，不论访问什么都是 Hello world 响应</p>
<h5 id="4使用多个处理器">4.使用多个处理器</h5>
<blockquote>
<p>1.服务器使用默认的 DefaultServeMux 作为处理器；不在 Server 结构的 Handler 字段中指定处理器<br>
2.通过 http.Handle 函数将处理器绑定到 DefaultServeMux</p>
</blockquote>
<p>注：Handle 函数虽然来源于 http 包，实际上是 ServeMux 结构的方法；http.Handle 等同 DefaultServeMux.Handle</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type HelloHandler struct {}

func (h *HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello!&quot;)
}

type WorldHandler struct {}

func (h *WorldHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;world!&quot;)
}

func main()  {
	hello:= HelloHandler{}
	world:= WorldHandler{}
	server := http.Server{
		Addr: &quot;127.0.0.1:10000&quot;,
	}
	http.Handle(&quot;/hello&quot;, &amp;hello)
	http.Handle(&quot;/world&quot;, &amp;world)
	
	//http://localhost:10000/
	//http://localhost:10000/hello
	//http://localhost:10000/world
	server.ListenAndServe()
}
</code></pre>
<h5 id="5处理器函数">5.处理器函数</h5>
<blockquote>
<p>处理器函数就是创建处理器的一种便利方式</p>
</blockquote>
<p>1.处理器函数</p>
<blockquote>
<p>1.与处理器拥有相同行为的函数；<br>
2.这些函数与 ServeHTTP 方法拥有相同的签名（即参数相同）；</p>
</blockquote>
<p>2.处理器函数实现原理</p>
<blockquote>
<p>定义了一种 HandlerFunc 函数类型，可以将一个带有正确签名的函数 f 转换成一个带有方法 f 的处理器</p>
</blockquote>
<p>1.例：</p>
<pre><code>func hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello!&quot;)
}

//HandlerFunc，将 hello 函数，转换成一个带有 hello 方法的处理器 helloHandler
//HandlerFunc 是定义的一种类型，此处是类型强制转化
helloHandler := HandlerFunc(hello)
</code></pre>
<p>2.源码：HandlerFunc定义</p>
<pre><code>type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
</code></pre>
<p>3.例：http.HandleFunc()</p>
<blockquote>
<p>注：不是 http.HandlerFunc()，二者意义不一样</p>
</blockquote>
<ul>
<li>HandleFunc()：封装的简化处理器定义的方法，底层调用 HandlerFunc()，进行类型转化</li>
<li>HandlerFunc()：定义的一种函数类型，将带有正确签名的函数 f 转换成一个带有方法 f 的处理器</li>
</ul>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

//与上边多处理器函数，函数定位对比
func hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello!&quot;)
}

func world(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;world!&quot;)
}

func main()  {
	server := http.Server{
		Addr: &quot;127.0.0.1:10000&quot;,
	}
	http.HandleFunc(&quot;/hello&quot;, hello)
	http.HandleFunc(&quot;/world&quot;, world)
	
	//http://localhost:10000/
	//http://localhost:10000/hello
	//http://localhost:10000/world
	server.ListenAndServe()
}
</code></pre>
<h5 id="6串联多个处理和和处理器函数">6.串联多个处理和和处理器函数</h5>
<blockquote>
<p>意义：防止代码重复、代码依赖</p>
</blockquote>
<p>串联处理器函数</p>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
)

func helloWorld(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Hello world!\n&quot;)
}

//串联时注意函数类型
func log(h http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, &quot;log!\n&quot;)
		h(w, r)
	}
}

func main()  {
	server := http.Server{
		Addr: &quot;127.0.0.1:10000&quot;,
	}
	http.HandleFunc(&quot;/hello&quot;, log(helloWorld))
	//http://localhost:10000/hello
	server.ListenAndServe()
}
</code></pre>
<h5 id="6servemux-和-defaultservemux">6.ServeMux 和 DefaultServeMux</h5>
<p>1.ServeMux</p>
<blockquote>
<p>1.是一个 HTTP请求的多路复用器；<br>
2.ServeMux 结构包含一个映射：URL映射到对应处理器（找出最为匹配的 URL）；<br>
3.因为ServeMux 结构实现了 ServeHTTP，所以是个处理器；</p>
</blockquote>
<p>2.DefaultServeMux</p>
<blockquote>
<p>1.是 ServeMux 结构的一个实例（不是实现）</p>
</blockquote>
<p>3.URL匹配规则</p>
<blockquote>
<p>1.如果绑定的 URL 不是以 / 结尾，完全匹配；<br>
2.如果绑定的 URL 是以 / 结尾（/hello/），往前匹配（/hello/aa）；</p>
</blockquote>
<h5 id="7其它多路复用器-httrouter">7.其它多路复用器 HttRouter</h5>
<blockquote>
<p>ServeMux缺陷：无法使用变量实现 URL 模式匹配</p>
</blockquote>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/julienschmidt/httprouter&quot;
	&quot;net/http&quot;
)

func hello2(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
	fmt.Fprintf(w, &quot;Hello %s!&quot;, p.ByName(&quot;name&quot;))
}


func main()  {
	mux := httprouter.New()
	mux.GET(&quot;/hello/:name&quot;, hello2)

	server := http.Server{
		Addr: &quot;127.0.0.1:10000&quot;,
	}
	server.ListenAndServe()
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-18.框架-gin]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-18kuang-jia-gin/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-18kuang-jia-gin/">
        </link>
        <updated>2021-10-12T03:17:51.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1安装">1.安装</h3>
<pre><code># 1.下载并安装
go get -u github.com/gin-gonic/gin

# 2.创建项目
mkdir ~/go_mod/ginTest
cd ~/go_mod/ginTest
go mod init ginTest

</code></pre>
<h4 id="1错误">1.错误</h4>
<p>1.go get ... time out</p>
<blockquote>
<p>注释掉 /etc/hosts 中的 github<br>
防止有其它代理，重启电脑</p>
</blockquote>
<h3 id="2快速开始">2.快速开始</h3>
<p>1.定义路由、监听端口</p>
<pre><code>package main

import (
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

func main() {
	// 使用默认中间件创建一个gin路由器
	// logger and recovery (crash-free) 中间件
	r := gin.Default()
	//定义get请求，路由user
	r.GET(&quot;/user&quot;, func(c *gin.Context) {
		//响应。字符串
		c.String(http.StatusOK, &quot;test&quot;)
	})

	// 默认启动的是 8080端口，也可以自己定义启动端口
	// router.Run(&quot;:3000&quot;)
	r.Run()
}
</code></pre>
<p>2.启动服务</p>
<pre><code># 会自动监听端口，不需要nginx等web配置
go run main.go
</code></pre>
<p>3.测试</p>
<pre><code># 端口不可省略
curl http://localhost:8080/user
</code></pre>
<h3 id="3常用功能">3.常用功能</h3>
<h4 id="1请求参数">1.请求参数</h4>
<h5 id="1get请求">1.GET请求</h5>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

func main() {
	r := gin.Default()
	//声明1：路由中声明参数
	r.GET(&quot;/user/:name/:action/&quot;, func(c *gin.Context) {
        name := c.Param(&quot;name&quot;)
        action := c.Param(&quot;action&quot;)
        c.String(http.StatusOK, &quot;%s is %s&quot;, name, action)
    })
    //声明2：*后的所有路由都作为参数action的值
    r.GET(&quot;/user/:name/*action&quot;, func(c *gin.Context) {
        name := c.Param(&quot;name&quot;)
        action := c.Param(&quot;action&quot;)
        c.String(http.StatusOK, &quot;%s is %s&quot;, name, action)
    })
	//声明3：从&amp;中获取参数
	r.GET(&quot;/user/login&quot;, func(c *gin.Context) {
		//接收get请求参数
		name := c.DefaultQuery(&quot;name&quot;, &quot;tom&quot;)
		password := c.Query(&quot;password&quot;)//c.Request.URL.Query().Get(&quot;&quot;)的简写
		//获取数组（字符串切片）
		common := c.QueryArray(&quot;common&quot;)

		fmt.Printf(&quot;name is %s, password is %s \n&quot;, name, password)
		fmt.Println(&quot;common params is: \n&quot;, common)

		c.String(http.StatusOK, &quot;Hi %s, welcome!&quot;, name)
	})
	r.Run()
}
</code></pre>
<p>验证</p>
<pre><code># 监听端口
go run main.go

# 测试
curl http://localhost:8080/user/login\?name\=john\&amp;password\=123456\&amp;common=1,2
</code></pre>
<h5 id="2post请求">2.POST请求</h5>
<blockquote>
<p>post请求，允许传递get形式的参数，通过get方式获取到对应参数</p>
</blockquote>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/gin-gonic/gin&quot;
	&quot;net/http&quot;
)

func main() {
	r := gin.Default()

	r.POST(&quot;/user/welcome&quot;, func(c *gin.Context) {
		name := c.PostForm(&quot;name&quot;)
		common := c.PostFormArray(&quot;common&quot;)

		fmt.Printf(&quot;name is %s\n&quot;, name)
		fmt.Println(&quot;common is: \n&quot;, common)

		c.JSON(http.StatusOK, gin.H{
			&quot;status&quot;: http.StatusOK,
			&quot;message&quot;: &quot;success&quot;,
		})
	})
	r.Run()
}
</code></pre>
<p>验证</p>
<pre><code># 监听端口
go run main.go

# 测试
curl -X POST -d &quot;name=quene&amp;common=1,2&quot;  http://localhost:8080/user/welcome
</code></pre>
<h4 id="2路由">2.路由</h4>
<h5 id="1路由分组">1.路由分组</h5>
<pre><code>func main() {
	router := gin.Default()

	// Simple group: v1
	v1 := router.Group(&quot;/v1&quot;)
	{
		v1.POST(&quot;/login&quot;, loginEndpoint)
		v1.POST(&quot;/submit&quot;, submitEndpoint)
		v1.POST(&quot;/read&quot;, readEndpoint)
	}

	// Simple group: v2
	v2 := router.Group(&quot;/v2&quot;)
	{
		v2.POST(&quot;/login&quot;, loginEndpoint)
		v2.POST(&quot;/submit&quot;, submitEndpoint)
		v2.POST(&quot;/read&quot;, readEndpoint)
	}

	router.Run(&quot;:8080&quot;)
}
</code></pre>
<h4 id="3中间件">3.中间件</h4>
<pre><code># 1.无中间件启动
r := gin.New()

# 2.添加中间件
# gin中 HandlerFunc 都是中间件
r.Use(gin.Logger())

# 3.路由添加中间件，可以添加任意多个
r.GET(&quot;/user/login&quot;, AuthRequired(), loginEndpoint)
</code></pre>
<h4 id="4日志">4.日志</h4>
<pre><code>
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-17.命令行程序库-cobra]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-17ming-ling-xing-cheng-xu-ku-cobra/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-17ming-ling-xing-cheng-xu-ku-cobra/">
        </link>
        <updated>2021-10-12T03:17:19.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<p><a href="https://zhuanlan.zhihu.com/p/103363533">Go 每日一库之 cobra</a></p>
<blockquote>
<p>编写命令行程序；<br>
同时，它也提供了一个脚手架（生成器），用于生成基于 cobra 的应用程序框架</p>
</blockquote>
<h3 id="1特性">1.特性</h3>
<ul>
<li>
<p>轻松支持子命令，如app server，app fetch等；</p>
</li>
<li>
<p>完全兼容 POSIX 选项（包括短、长选项）；</p>
</li>
<li>
<p>嵌套子命令；</p>
</li>
<li>
<p>全局、本地层级选项。可以在多处设置选项，按照一定的顺序取用；</p>
</li>
<li>
<p>使用脚手架轻松生成程序框架和命令；</p>
</li>
<li>
<p>设置钩子函数，在命令执行前、后执行某些操作；</p>
</li>
<li>
<p>生成 Markdown/ReStructed Text/Man Page 格式的文档；</p>
</li>
</ul>
<h3 id="2基本概念">2.基本概念</h3>
<ul>
<li>
<p>命令（Command）：就是需要执行的操作；</p>
</li>
<li>
<p>参数（Arg）：命令的参数，即要操作的对象；</p>
</li>
<li>
<p>选项（Flag）：命令选项可以调整命令的行为。</p>
</li>
</ul>
<pre><code># 例：
# hugo 命令，server 子命令，--port 选项
hugo server --port 1234
# git 命令，clone 子命令，URL 参数，--bare 选项
git clone URL --bare
</code></pre>
<h3 id="3快速使用">3.快速使用</h3>
<h4 id="1安装库">1.安装库</h4>
<blockquote>
<p>注：会在 <code>$GOPATH/bin</code> 目录下创建一个名叫cobra可执行文件。</p>
</blockquote>
<pre><code># 1.安装包 cobra
# -u：更新已有的代码包及其依赖包
# 没 -u，包已存在时，不会更新
go get -u github.com/spf13/cobra/cobra

# 2.确认 cobra 是否被安装在了 $GOPATH/bin下
# 注：防止 $GOPATH 失效，导致安装的 go 命令，不可执行
ls -al $GOPATH/bin | grep cobra
</code></pre>
<h4 id="2错误command-not-found-cobra">2.错误：command not found: cobra</h4>
<blockquote>
<p>cobra没能正常安装。<br>
引入 $GOPATH，重新安装</p>
</blockquote>
<ul>
<li>注1：电脑重启后，~/.base_profile 定义的 $GOPATH 可能会失效</li>
<li>注2：已经安装过的go命令，后续突然不可执行了，基本都是 $GOPATH 失效，例：gmchart</li>
</ul>
<p><img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210323160756.png" alt="" loading="lazy"><br>
<img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210323160820.png" alt="" loading="lazy"></p>
<h4 id="3脚手架">3.脚手架</h4>
<pre><code># 1.初始化
# appName：项目名，只能是相对路径
# --pkg-name：包名。main.go 中 import 的包名
# cobra init appName --pkg-name pgkName
cobra init go_mod/monitor --pkg-name monitor

# 2.添加子命令
cobra add {childCmd}
</code></pre>
<h5 id="1gopath">1.GOPATH</h5>
<pre><code># 1.进入 $GOPATH/src
cd $GOPATH/src

# 2.初始化
cobra init monitor --pkg-name monitor

# 3.编译
# -o：自定义编译文件名
# {cmd}：自定义可执行文件名
# 编译后的文件，可以在任意目录执行
# go build -o {cmd}
go build -o monitor

# 4.执行
./monitor
</code></pre>
<h5 id="2go-mod">2.go mod</h5>
<blockquote>
<p>非 $GOPATH 目录，需要使用 go mod 模式。<br>
否则 cobra 初始化后，找不到对应包</p>
</blockquote>
<pre><code># 1.使用 cobra 生成项目
cobra init monitorCobra --pkg-name monitorCobra

# 2.使用 go mod
cd monitorCobra
go mod init monitorCobra

# 3.下载依赖包 go mod
# go1.15
go mod download
go run main.go
# go1.16
go mod vendor
# 第三种
go mod tidy -v

# 4.重新在 ide 打开

# 5.编译
go build -o monitor

# 6.执行
./monitor
</code></pre>
<h3 id="4简单介绍">4.简单介绍</h3>
<h4 id="1执行">1.执行</h4>
<pre><code># 1.执行
# 不要直接 go run，需要编译成可执行命令
go build -o {cmd}

# 2.帮助信息
./{cmd} -h
./{cmd} {child_cmd} -h
</code></pre>
<h4 id="2命令">2.命令</h4>
<blockquote>
<p>命令、子命令，都是用 Cobra.Command{}结构体表示；<br>
常用的结构体属性：Use/Short/Long/Run</p>
</blockquote>
<pre><code># 1.Use：命令怎么被调用
# 格式：name arg1 [arg2]
# name命令，arg1必填参数，arg2可选参数，参数可以多个

# 2.Short/Long：命令的帮助信息，前者简短，后者详尽

# 3.Run：实际执行操作的函数
</code></pre>
<h4 id="3选项">3.选项</h4>
<blockquote>
<p>永久选项（命令、子命令都可使用）<br>
本地选项（子命令）<br>
pflag包解析</p>
</blockquote>
<pre><code># 1.永久选项 rootCmd
# 参数：接收变量、长选项、短选项名、默认值和、帮助信息
var Verbose bool
rootCmd.PersistentFlags().BoolVarP(&amp;Verbose, &quot;verbose&quot;, &quot;v&quot;, false, &quot;verbose output&quot;)

# 2.本地选项 {childCmd}
var Source string
{childCmd}.Flags().StringVarP(&amp;Source, &quot;source&quot;, &quot;s&quot;, &quot;&quot;, &quot;Source directory to read from&quot;)
</code></pre>
<h4 id="4配置文件">4.配置文件</h4>
<pre><code># 方法1.脚手架生成后，会自动绑定选项 config，允许在命令行中指定
func init() {
    // initConfig 函数会在绑定选项后，才执行
	cobra.OnInitialize(initConfig)

    rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (default is $HOME/.monitorCobra.yaml)&quot;)
}

func initConfig() {...}

# 方法2.手动在项目中写死
func initConfig() {
    //直接写死，不接收选项自定义
    cfgFile = &quot;./conf/config.yaml&quot;
    ...
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-16.例：监控脚本]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-16li-jian-kong-jiao-ben/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-16li-jian-kong-jiao-ben/">
        </link>
        <updated>2021-10-12T03:16:30.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h3 id="1go-mod模式">1.go mod模式</h3>
<pre><code># 1.初始化模块
go mod init [module]

# 2.下载第三方包
go mod download

# 3.ide引入第三方包（运行时会引入第三方包）
go run ...
</code></pre>
<h3 id="2go-mod-flags包">2.go mod + flags包</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/shizq/imgs/raw/master/PicGo/20210323141301.png" alt="" loading="lazy"></figure>
<p>1.新建包</p>
<pre><code>mkdir monitor
go mod init monitor
</code></pre>
<p>2.新增 main.go</p>
<pre><code>package main

import (
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;monitor/helpers&quot;
	&quot;path&quot;
	&quot;runtime&quot;
	&quot;strings&quot;
)

var (
	processName string
	cmd string
	currFileName string
)

func init()  {
	flag.StringVar(&amp;processName, &quot;processName&quot;, &quot;&quot;, &quot;var process name&quot;)

	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yml&quot;)
	viper.AddConfigPath(&quot;./conf&quot;)
	err := viper.ReadInConfig()
	if err != nil {
		fmt.Printf(&quot;配置文件读取失败：%s&quot;, err.Error())
	}
}

func main() {
	getCurrFileName()
	getCmd()
	helpers.Monitor(cmd, processName)

	//读取db配置
	//db := structs.Db{}
	//db.ShowConfInfo()
}

func getCmd()  {
	flag.Parse()

	//获取进程id，排除grep进程、当前go进程
	//问题：字符串拼接有几种方式？
	cmd = &quot;ps -ef | grep &quot; + processName + &quot; | grep -v grep | grep -v &quot; + currFileName + &quot; | awk '{print $2}'&quot;
	fmt.Printf(&quot;cmd：%s \n&quot;, cmd)
}

func getCurrFileName()  {
	//fmt.Println(os.Args)
	//文件全路径
	_, fullFileName, _, _ := runtime.Caller(0)

	//文件名
	fileName := path.Base(fullFileName)
	//后缀名
	fileSuffix := path.Ext(fileName)
	//不含后缀的文件名
	currFileName = strings.TrimSuffix(fileName, fileSuffix)
	fmt.Printf(&quot;当前文件名称：%s \n&quot;, currFileName)
}
</code></pre>
<p>3.新增配置文件 conf.yml</p>
<pre><code>dingDing:
  url: &quot;https://oapi.dingtalk.com/robot/send?access_token=ae4f397ec3fc9310ce418dd23ac4649631b75bc1128836fdb8f8bef89fb27d3c&quot;
db:
  redis:
    ip: &quot;127.0.0.1&quot;
    port: &quot;6379&quot;
    aa: &quot;11&quot;
  mysql:
    ip: &quot;127.0.0.1&quot;
    port: &quot;3306&quot;
    bb: &quot;22&quot;
</code></pre>
<p>4.新增结构体</p>
<pre><code># 1.db 结构体
package structs

import (
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
)

type Db struct {
	Db DbConf
}

type DbConf struct {
	Redis Redis
	Mysql Mysql
}

type Redis struct {
	Ip string
	Port string
	Aa string
}

type Mysql struct {
	Ip string
	Port string
	Bb string
}

func (d *Db) ShowConfInfo()  {
	viper.Unmarshal(d)

	fmt.Printf(&quot;mysql ip：%s，port: %s \n&quot;, d.Db.Mysql.Ip, d.Db.Mysql.Port)
	fmt.Printf(&quot;redis ip：%s，port: %s \n&quot;, d.Db.Redis.Ip, d.Db.Redis.Port)
}

# 2.dingding结构体
package structs

import (
	&quot;fmt&quot;
	&quot;net/http&quot;
	&quot;strings&quot;
)

type DingDing struct {
	DingDing DingConf
}

type DingConf struct {
	Url string
}

func (d *DingDing) SendDingMsg(url, title, msg string) bool {
	format := `### %s \n\n #### %s \n\n`
	text := fmt.Sprintf(format, title, msg)
	content := `{&quot;msgtype&quot;: &quot;markdown&quot;,
					&quot;markdown&quot;: {
            			&quot;title&quot;:&quot;` + title + `&quot;,
            			&quot;text&quot;: &quot;` + text + `&quot;
        			}
			}`
	req, err := http.NewRequest(&quot;POST&quot;, url, strings.NewReader(content))
	if err != nil {
		fmt.Printf(&quot;建立请求失败：%s&quot;, err.Error())
		return false
	}
	req.Header.Set(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;)

	client := &amp;http.Client{}
	rst, err := client.Do(req)
	defer rst.Body.Close()
	if err != nil {
		fmt.Printf(&quot;请求发送失败：%s&quot;, err.Error())
		return false
	}

	return true
}
</code></pre>
<p>5.新增 helpers</p>
<pre><code># 1.monitor类
package helpers

import (
	&quot;fmt&quot;
	&quot;os/exec&quot;
	&quot;strings&quot;
)

func Monitor(cmd, processName string) {
	rst, err := exec.Command(&quot;/bin/sh&quot;, &quot;-c&quot;, cmd).Output()
	if err != nil {
		fmt.Printf(&quot;cmd exec failed! %s \n&quot;, err.Error())
	}

	//将字节转化成字符串，去掉2边的空格
	pid := strings.TrimSpace(string(rst))
	if pid == &quot;&quot; {
		//发送钉钉报警消息
		SendDingMsg(processName)
	} else {
		fmt.Printf(&quot;pid：%s \n&quot;, pid)
	}
}

# 2.common类
package helpers

import (
	&quot;github.com/spf13/viper&quot;
	&quot;monitor/structs&quot;
)

func SendDingMsg(msg string) {
	var d structs.DingDing
	viper.Unmarshal(&amp;d)

	//fmt.Println(d.DingDing.Url)
	d.SendDingMsg(d.DingDing.Url, &quot;监控脚本报警&quot;, &quot;脚本 &quot; + msg + &quot; 意外停止，请及时处理!!&quot;)
}
</code></pre>
<p>6.执行</p>
<pre><code>go run main.go -processName mysql
</code></pre>
<h3 id="3go-mod-go-flags包">3.go mod + go-flags包</h3>
<blockquote>
<p>与上诉唯一不同，声明命令行参数的方式</p>
</blockquote>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/jessevdk/go-flags&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;monitorFlags/helpers&quot;
	&quot;path&quot;
	&quot;runtime&quot;
	&quot;strings&quot;
)

var (
	processName string
	cmd string
	currFileName string
)

type Option struct {
	PName string `short:&quot;n&quot; long:&quot;pName&quot; description:&quot;var process name&quot;`
}

func init()  {
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yml&quot;)
	viper.AddConfigPath(&quot;./conf&quot;)
	err := viper.ReadInConfig()
	if err != nil {
		fmt.Printf(&quot;配置文件读取失败：%s&quot;, err.Error())
	}
}

func main() {
	getCurrFileName()
	getCmd()
	helpers.Monitor(cmd, processName)
}

func getCmd()  {
	var opt Option
	flags.Parse(&amp;opt)
	processName = opt.PName

	//获取进程id，排除grep进程、当前go进程
	//问题：字符串拼接有几种方式？
	cmd = &quot;ps -ef | grep &quot; + processName + &quot; | grep -v grep | grep -v &quot; + currFileName + &quot; | awk '{print $2}'&quot;
	fmt.Printf(&quot;cmd：%s \n&quot;, cmd)
}

func getCurrFileName()  {
	//fmt.Println(os.Args)
	//文件全路径
	_, fullFileName, _, _ := runtime.Caller(0)

	//文件名
	fileName := path.Base(fullFileName)
	//后缀名
	fileSuffix := path.Ext(fileName)
	//不含后缀的文件名
	currFileName = strings.TrimSuffix(fileName, fileSuffix)
	fmt.Printf(&quot;当前文件名称：%s \n&quot;, currFileName)
}
</code></pre>
<p>执行</p>
<pre><code>go run main.go -n mysql
</code></pre>
<h3 id="4go-mod-cobra">4.go mod + cobra</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[go学习-15.配置管理工具-viper]]></title>
        <id>https://wo-wo.github.io/post/go-xue-xi-15pei-zhi-guan-li-gong-ju-viper/</id>
        <link href="https://wo-wo.github.io/post/go-xue-xi-15pei-zhi-guan-li-gong-ju-viper/">
        </link>
        <updated>2021-10-12T03:16:06.000Z</updated>
        <content type="html"><![CDATA[<p>[toc]</p>
<h4 id="1特性">1.特性</h4>
<ul>
<li>1.支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；</li>
<li>2.从环境变量、命令行选项和io.Reader中读取配置</li>
<li>3.可以设置监听配置文件的修改，修改时自动加载新的配置</li>
<li>4.从远程配置系统中读取和监听修改，如 etcd/Consul</li>
</ul>
<h4 id="2快速使用">2.快速使用</h4>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
)

func main()  {
	//设置文件名（不要带后缀）、类型、搜索路径（可以多个）、默认值
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	viper.AddConfigPath(&quot;.&quot;)
	viper.SetDefault(&quot;redis.port&quot;, 6379)
	err := viper.ReadInConfig()
	if err != nil {
		log.Fatal(&quot;read config failed:%v&quot;, err)
	}

	fmt.Println(viper.Get(&quot;app_name&quot;))
	fmt.Println(viper.Get(&quot;redis.port&quot;))
}
</code></pre>
<h4 id="3读取键">3.读取键</h4>
<pre><code># 1.Get(key)
# Get方法返回一个interface{}的值，使用有所不便
viper.Get(&quot;redis.port&quot;)

# 2.GetType(key)
# Type:Int/IntSlice/String/StringSlice/Time/Duration等
# 如果指定的键不存在或类型不正确，GetType方法返回对应类型的零值
viper.GetInt(&quot;redis.port&quot;)
</code></pre>
<h4 id="4设置键值">4.设置键值</h4>
<ol>
<li>可以多个地方设置，优先级（从高到低）</li>
</ol>
<ul>
<li>viper.Set()</li>
<li>命令行选项</li>
<li>环境变量</li>
<li>配置文件</li>
<li>默认值</li>
</ul>
<pre><code># 1.set
viper.Set(&quot;redis.port&quot;, 5381)

# 2.命令行选项
# viper 使用 pflag 库来解析选项
# 解析：pflag.Parse
func init() {
  pflag.Int(&quot;redis.port&quot;, 8381, &quot;Redis port to connect&quot;)

  // 绑定命令行
  viper.BindPFlags(pflag.CommandLine)
}

# 3.环境变量
func init() {
  // 绑定环境变量-全绑定
  viper.AutomaticEnv()
  
  // 绑定环境变量-单独绑定
  // 一个参数：即是键名，也是环境变量名
  viper.BindEnv(&quot;redis.port&quot;)
  // 二个参数：前边键名，后边环境变量名
  // 注：如果对应环境变量不存在，自动将键名全部转为大写再查找一次
  viper.BindEnv(&quot;go.path&quot;, &quot;GOPATH&quot;)
}
# 验证
func main() {
  // 可以设置前缀 viper.SetEnvPrefix
  // Get的时候，viper 会自动加上这个前缀再从环境变量中查找
  fmt.Println(&quot;GOPATH: &quot;, viper.Get(&quot;GOPATH&quot;))
}

# 4.配置文件
viper.SetConfigName(&quot;config&quot;)
viper.SetConfigType(&quot;yaml&quot;)
viper.AddConfigPath(&quot;.&quot;)
viper.ReadInConfig()

# 5.默认值
viper.SetDefault(&quot;redis.port&quot;, 6379)
</code></pre>
<h4 id="5读取配置">5.读取配置</h4>
<h5 id="1从ioreader中读取">1.从io.Reader中读取</h5>
<blockquote>
<p>这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。</p>
</blockquote>
<pre><code>package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
)

func main()  {
	viper.SetConfigType(&quot;toml&quot;)
	tomlConfig := []byte(`
app_name = &quot;awesome web&quot;

[redis]
ip = &quot;127.0.0.1&quot;
port = 7381
`)
	err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))
	if err != nil {
		log.Fatal(&quot;read config failed:%v&quot;, err)
	}

	fmt.Println(&quot;redis port&quot;, viper.GetInt(&quot;redis.port&quot;))
}
</code></pre>
<h5 id="2unmarshal-反序列化">2.Unmarshal 反序列化</h5>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
)

type Conf struct {
	AppName string
	Redis RedisConf
}

type RedisConf struct {
	IP string
	Port int
}

func main()  {
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	viper.AddConfigPath(&quot;.&quot;)
	err := viper.ReadInConfig()
	if err != nil {
		log.Fatal(&quot;read config failed:%v&quot;, err)
	}

	//将配置信息，反序列化到声明的结构体 Conf
	// Unmarshal：一次性将所有配置属性，发序列化到一个结构体。结构体数量，根据配置文件层级，依次定义
	// UnmarshalKey：俺需要读取指定配置内容，到某个结构体。更简洁
	var c Conf
	viper.Unmarshal(&amp;c)
	//或
	viper.UnmarshalKey(&quot;redis&quot;, &amp;c)

	fmt.Println(c.Redis)
}
</code></pre>
<h4 id="6保存配置">6.保存配置</h4>
<ul>
<li>WriteConfig:配置写到预定义路径，文件存在，覆盖。不存在，报错</li>
<li>SafeWriteConfig:配置写到预定义路径，文件存在，不覆盖</li>
<li>WriteConfigAs:保存配置到指定路径，文件存在，覆盖</li>
<li>SafeWriteConfigAs:保存配置到指定路径，文件存在，不覆盖</li>
</ul>
<pre><code>package main

import (
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
)

func main()  {
	viper.Set(&quot;redis.ip&quot;, &quot;127.0.0.1&quot;)
	viper.Set(&quot;redis.port&quot;, &quot;6379&quot;)

	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	viper.AddConfigPath(&quot;.&quot;)

	err := viper.SafeWriteConfig()
	if err != nil {
		log.Fatal(&quot;write config failed:&quot;, err)
	}
}
</code></pre>
<h4 id="7监听文件修改">7.监听文件修改</h4>
<blockquote>
<p>可以监听文件修改，热加载配置，不需要重启<br>
viper.WatchConfig()</p>
</blockquote>
<pre><code>package main

import (
	&quot;fmt&quot;
	&quot;github.com/spf13/viper&quot;
	&quot;log&quot;
	&quot;time&quot;
)

func main() {
	viper.SetConfigName(&quot;config&quot;)
	viper.SetConfigType(&quot;yaml&quot;)
	viper.AddConfigPath(&quot;.&quot;)
	err := viper.ReadInConfig()
	if err != nil {
		log.Fatal(&quot;read config failed:&quot;, err)
	}

	//监听文件修改，热加载配置
	viper.WatchConfig()
	fmt.Println(&quot;redis port before sleep:&quot;, viper.Get(&quot;redis.port&quot;))
	time.Sleep(time.Second * 10)
	fmt.Println(&quot;redis port after sleep:&quot;, viper.Get(&quot;redis.port&quot;))
}
</code></pre>
]]></content>
    </entry>
</feed>